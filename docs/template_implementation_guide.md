# ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå®Ÿè£…æ‰‹é †æ›¸ - 2025å¹´6æœˆç¾è¡Œå®Ÿè£…ç‰ˆ

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€**Lyralive v0.6.0**ã®Electronãƒ™ãƒ¼ã‚¹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§æ–°ã—ã„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®è©³ç´°ãªæ‰‹é †ã‚’èª¬æ˜ã—ã¾ã™ã€‚å®Ÿè£…æ¸ˆã¿ã®FadeSlideTextã€MultiLineTextã€GlitchTextã€WordSlideTextãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®**å®Ÿéš›ã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³**ã‚’åŸºã«ã€é«˜åº¦ãªæ©Ÿèƒ½ï¼ˆPixiJSãƒ•ã‚£ãƒ«ã‚¿ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£æ“ä½œã€æ–‡å­—ã‚«ã‚¦ãƒ³ãƒˆç®¡ç†ç­‰ï¼‰ã‚’å«ã‚€çµ±ä¸€ã•ã‚ŒãŸæ–¹æ³•ã§é«˜å“è³ªãªãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½œæˆã§ãã‚‹ã‚ˆã†æŒ‡å°ã—ã¾ã™ã€‚

## ç›®æ¬¡
1. [å‰æçŸ¥è­˜ã¨æº–å‚™](#å‰æçŸ¥è­˜ã¨æº–å‚™)
2. [ç¾è¡Œã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç†è§£](#ç¾è¡Œã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç†è§£)
3. [åŸºæœ¬æ§‹é€ ã®å®Ÿè£…](#åŸºæœ¬æ§‹é€ ã®å®Ÿè£…)
4. [æ–‡å­—ãƒ»å˜èªã‚«ã‚¦ãƒ³ãƒˆç®¡ç†](#æ–‡å­—ãƒ»å˜èªã‚«ã‚¦ãƒ³ãƒˆç®¡ç†)
5. [PixiJSãƒ•ã‚£ãƒ«ã‚¿ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå®Ÿè£…](#PixiJSãƒ•ã‚£ãƒ«ã‚¿ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå®Ÿè£…)
6. [ãƒ†ã‚¯ã‚¹ãƒãƒ£æ“ä½œã¨RenderTextureæ´»ç”¨](#ãƒ†ã‚¯ã‚¹ãƒãƒ£æ“ä½œã¨RenderTextureæ´»ç”¨)
7. [éšå±¤å¯¾å¿œã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…](#éšå±¤å¯¾å¿œã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…)
8. [FontServiceçµ±åˆã¨ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†](#FontServiceçµ±åˆã¨ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†)
9. [ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æŠ€æ³•](#ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æŠ€æ³•)
10. [ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ‡ãƒãƒƒã‚°](#ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ‡ãƒãƒƒã‚°)
11. [ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ¬ã‚¸ã‚¹ãƒˆãƒªã¸ã®ç™»éŒ²](#ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ¬ã‚¸ã‚¹ãƒˆãƒªã¸ã®ç™»éŒ²)
12. [å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ç·åˆã‚¬ã‚¤ãƒ‰](#å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ç·åˆã‚¬ã‚¤ãƒ‰)

---

## å‰æçŸ¥è­˜ã¨æº–å‚™

### å¿…è¦ãªçŸ¥è­˜
1. **PIXI.js ã®åŸºæœ¬æ¦‚å¿µ**
   - Container, Graphics, Text ã®ä½¿ã„æ–¹
   - è¦ªå­é–¢ä¿‚ã¨ãƒ­ãƒ¼ã‚«ãƒ«/ã‚°ãƒ­ãƒ¼ãƒãƒ«åº§æ¨™
   - ã‚¤ãƒ™ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã¨ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«

2. **è¤‡æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¯¾å¿œã‚·ã‚¹ãƒ†ãƒ ** âœ¨ **å®Œå…¨å®Ÿè£…æ¸ˆã¿**
   - éšå±¤æ§‹é€ ï¼šãƒ•ãƒ¬ãƒ¼ã‚º > å˜èª > æ–‡å­—
   - ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç¶™æ‰¿ï¼šè¦ªã‹ã‚‰å­ã¸ã®è‡ªå‹•ç¶™æ‰¿
   - ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç®¡ç†ï¼šéšå±¤çš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
   - ä¸€æ‹¬æ“ä½œï¼šè¤‡æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®åŒæ™‚é©ç”¨
   - **ğŸ†• Undo/Redoæ©Ÿèƒ½ï¼š20ã‚¹ãƒ†ãƒƒãƒ—å±¥æ­´ç®¡ç†**
   - **ğŸ†• ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¿æŒï¼šãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¤‰æ›´æ™‚ã®é«˜åº¦ãªä¿æŒãƒ­ã‚¸ãƒƒã‚¯**

3. **å®Ÿè£…æ¸ˆã¿ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
   - `TemplateManager`: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç®¡ç†ã¨å‰²ã‚Šå½“ã¦
   - `ParameterManager`: éšå±¤çš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç®¡ç†ï¼ˆæ”¹å–„ç‰ˆï¼‰
   - `ProjectStateManager`: çŠ¶æ…‹ä¿å­˜ã¨Undo/Redoæ©Ÿèƒ½
   - `InstanceManager`: ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç®¡ç†ã¨ç¶™æ‰¿
   - `templateRegistry`: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¸­å¤®ç™»éŒ²

### æº–å‚™ã™ã‚‹è¦ç´ 
1. **å‹å®šç¾©ã®ç†è§£**
   ```typescript
   interface IAnimationTemplate {
     metadata: { params: ParameterDefinition[] };
     
     // ğŸ†• éšå±¤å¯¾å¿œãƒ¡ã‚¤ãƒ³å®Ÿè£…ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¿…é ˆï¼‰
     animateContainer?(container, text, params, nowMs, startMs, endMs, hierarchyType, phase): boolean;
     
     // ğŸ†• éšå±¤æ§‹é€ ä¿æŒã®ãŸã‚ã®è¦ç´ å‰Šé™¤ï¼ˆå¿…é ˆï¼‰
     removeVisualElements?(container): void;
     
     // ğŸ†• éšå±¤åˆ¥ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ¨å¥¨ï¼‰
     renderPhraseContainer?(container, text, params, nowMs, startMs, endMs, phase, hierarchyType): boolean;
     renderWordContainer?(container, text, params, nowMs, startMs, endMs, phase, hierarchyType): boolean; 
     renderCharContainer?(container, text, params, nowMs, startMs, endMs, phase, hierarchyType): boolean;
     
     // å¾“æ¥äº’æ›æ€§ãƒ¡ã‚½ãƒƒãƒ‰
     animate?(container, text, x, y, params, nowMs, startMs, endMs): void;
   }
   ```

2. **éšå±¤ç¶™æ‰¿ã‚·ã‚¹ãƒ†ãƒ ã®ç†è§£**
   ```typescript
   // ğŸ†• å®Ÿéš›ã®ç¶™æ‰¿ä¾‹ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
   phrase_0: "FadeSlideText"           // ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ¬ãƒ™ãƒ«è¨­å®š
     â””â”€â”€ phrase_0_word_1: (ç¶™æ‰¿)        // è‡ªå‹•ç¶™æ‰¿
         â””â”€â”€ phrase_0_word_1_char_2: (ç¶™æ‰¿)  // è‡ªå‹•ç¶™æ‰¿
   
   phrase_1: "MultiLineText"           // åˆ¥ãƒ•ãƒ¬ãƒ¼ã‚º
     â””â”€â”€ phrase_1_word_0: "CustomTemplate"  // ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
         â””â”€â”€ phrase_1_word_0_char_0: (ç¶™æ‰¿)    // CustomTemplateã‚’ç¶™æ‰¿
   ```

---

## ç¾è¡Œã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç†è§£

### å®Ÿè£…å®Œäº†ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

#### 1. ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‰²ã‚Šå½“ã¦ã‚·ã‚¹ãƒ†ãƒ  âœ…
```typescript
// Engine.ts ã§ã®ä½¿ç”¨ä¾‹ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
engine.assignTemplate('phrase_0', 'FadeSlideText');  // ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ¬ãƒ™ãƒ«è¨­å®š
engine.assignTemplate('phrase_0_word_1', 'CustomTemplate');  // å˜èªãƒ¬ãƒ™ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰

// ğŸ†• ä¸€æ‹¬å‰²ã‚Šå½“ã¦ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
engine.batchAssignTemplate(['phrase_0', 'phrase_1', 'phrase_2'], 'FadeSlideText', true);
```

#### 2. éšå±¤çš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç®¡ç† âœ… **æ”¹å–„ç‰ˆå®Ÿè£…æ¸ˆã¿**
```typescript
// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å„ªå…ˆé †ä½ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
// 1. ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (phrase_0_word_1ã®å€‹åˆ¥è¨­å®š)
// 2. è¦ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (phrase_0ã®è¨­å®š)  
// 3. ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (å…¨ä½“è¨­å®š)
// 4. ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ (ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ¨™æº–å€¤)

// ğŸ†• æ”¹å–„ã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ä¾‹
const effectiveParams = parameterManager.getEffectiveParams('phrase_0_word_1_char_2', templateId);

// ğŸ†• ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¤‰æ›´æ™‚ã®é«˜åº¦ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¿æŒï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
parameterManager.handleTemplateChange(
  oldTemplateId, 
  newTemplateId, 
  objectId, 
  preserveParams  // å…±é€šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ + é‡è¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ä¿æŒ
);
```

#### 3. ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç¶™æ‰¿ãƒ­ã‚¸ãƒƒã‚¯ âœ…
```typescript
// TemplateManager.ts - getTemplateForObject()ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
function getTemplateForObject(objectId: string): IAnimationTemplate {
  // 1. ç›´æ¥å‰²ã‚Šå½“ã¦ã‚’ãƒã‚§ãƒƒã‚¯
  if (assignments.has(objectId)) {
    return templates.get(assignments.get(objectId)!)!;
  }
  
  // 2. è¦ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†å¸°çš„ã«ãƒã‚§ãƒƒã‚¯
  const parentId = getParentObjectId(objectId);
  if (parentId) {
    return getTemplateForObject(parentId); // å†å¸°çš„ç¶™æ‰¿
  }
  
  // 3. ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
  return templates.get(defaultTemplateId)!;
}
```

#### 4. ğŸ†• Undo/Redo ã‚·ã‚¹ãƒ†ãƒ  âœ… **å®Œå…¨å®Ÿè£…æ¸ˆã¿**
```typescript
// ProjectStateManager ã§ã®çŠ¶æ…‹ç®¡ç†ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¤‰æ›´å‰ã®è‡ªå‹•çŠ¶æ…‹ä¿å­˜
engine.assignTemplate(objectId, templateId, preserveParams, saveState: true);

// Undo/Redoæ“ä½œ
const canUndo = engine.canUndo();  // å®Ÿè£…æ¸ˆã¿
const canRedo = engine.canRedo();  // å®Ÿè£…æ¸ˆã¿
engine.undo();  // 20ã‚¹ãƒ†ãƒƒãƒ—å±¥æ­´ã‹ã‚‰å¾©å…ƒ
engine.redo();  // çŠ¶æ…‹ã®å†é©ç”¨
```

---

## åŸºæœ¬æ§‹é€ ã®å®Ÿè£…

### ã‚¹ãƒ†ãƒƒãƒ— 1: ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆã¨ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

```typescript
import * as PIXI from 'pixi.js';
import { IAnimationTemplate, HierarchyType, AnimationPhase } from '../types/types';

/**
 * [ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå] - è¤‡æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¯¾å¿œãƒ»å®Ÿè£…å®Œäº†ç‰ˆæº–æ‹ 
 * [æ¦‚è¦èª¬æ˜]
 */
export const [ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå]: IAnimationTemplate = {
  metadata: {
    params: [
      // ğŸ†• æ”¹å–„ã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å®šç¾©ï¼ˆéšå±¤ç¶™æ‰¿ã‚’è€ƒæ…®ï¼‰
      // åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
      { name: "fontSize", type: "number", default: 32, min: 12, max: 128, step: 1 },
      { 
        name: "fontFamily", 
        type: "string", 
        default: "Arial",
        // ğŸ†• é¸æŠè‚¢å¯¾å¿œï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
        options: [
          { value: "Arial", label: "Arial" },
          { value: "Helvetica", label: "Helvetica" },
          { value: "Hiragino Sans", label: "Hiragino Sans" },
          // ... ä»–ã®é¸æŠè‚¢
        ]
      },
      
      // ğŸ†• çŠ¶æ…‹åˆ¥è‰²è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆFadeSlideTextã§å®Ÿè£…æ¸ˆã¿ï¼‰
      { name: "defaultTextColor", type: "color", default: "#808080" },
      { name: "activeTextColor", type: "color", default: "#FF0000" },
      { name: "completedTextColor", type: "color", default: "#800000" },
      
      // ğŸ†• ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
      { name: "headTime", type: "number", default: 500, min: 0, max: 2000, step: 50 },
      { name: "tailTime", type: "number", default: 500, min: 0, max: 2000, step: 50 },
      
      // ğŸ†• éšå±¤åˆ¥ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆç¶™æ‰¿å¯èƒ½ï¼‰
      { name: "phraseOffsetX", type: "number", default: 0, min: -200, max: 200, step: 1 },
      { name: "wordOffsetX", type: "number", default: 0, min: -100, max: 100, step: 1 },
      { name: "charOffsetX", type: "number", default: 0, min: -50, max: 50, step: 1 },
      
      // ğŸ†• ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»ãƒ‡ãƒãƒƒã‚°é–¢é€£
      { name: "debugMode", type: "boolean", default: false }
    ]
  },
  
  // ğŸ†• éšå±¤æ§‹é€ ä¿æŒã®ãŸã‚ã®è¦ç´ å‰Šé™¤ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¿…é ˆå®Ÿè£…ï¼‰
  removeVisualElements(container) {
    // å®Ÿè£…å†…å®¹ï¼ˆå¾Œè¿°ï¼‰
  },
  
  // ğŸ†• éšå±¤ç¶™æ‰¿å¯¾å¿œã®ãƒ¡ã‚¤ãƒ³å®Ÿè£…ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¿…é ˆå®Ÿè£…ï¼‰
  animateContainer(container, text, params, nowMs, startMs, endMs, hierarchyType, phase) {
    // å®Ÿè£…å†…å®¹ï¼ˆå¾Œè¿°ï¼‰
  },
  
  // ğŸ†• éšå±¤åˆ¥ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ¨å¥¨å®Ÿè£…ï¼‰
  renderPhraseContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType) {
    // ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ¬ãƒ™ãƒ«ã®å®Ÿè£…
  },
  
  renderWordContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType) {
    // å˜èªãƒ¬ãƒ™ãƒ«ã®å®Ÿè£…
  },
  
  renderCharContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType) {
    // æ–‡å­—ãƒ¬ãƒ™ãƒ«ã®å®Ÿè£…
  }
};

export default [ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå];
```

### ã‚¹ãƒ†ãƒƒãƒ— 2: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ¬ã‚¸ã‚¹ãƒˆãƒªã¸ã®ç™»éŒ²

```typescript
// templates/registry/templateRegistry.ts ã¸ã®è¿½åŠ 
export const templateRegistry: TemplateRegistryEntry[] = [
  // æ—¢å­˜ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
  {
    id: 'fadeslidetext',
    name: 'ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ†ã‚­ã‚¹ãƒˆ',
    template: templates.FadeSlideText
  },
  
  // ğŸ†• æ–°ã—ã„ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’è¿½åŠ 
  {
    id: 'yourtemplate',
    name: 'ã‚ãªãŸã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ',
    template: templates.YourTemplate
  }
];
```

---

## æ–‡å­—ãƒ»å˜èªã‚«ã‚¦ãƒ³ãƒˆç®¡ç†

### ç¾è¡Œå®Ÿè£…ã«ãŠã‘ã‚‹æ–‡å­—ãƒ»å˜èªã‚«ã‚¦ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ 

#### 1. åŸºæœ¬çš„ãªã‚«ã‚¦ãƒ³ãƒˆæ§‹é€ ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰

```typescript
// CharUnit ã®å®Ÿè£…æ§‹é€ ï¼ˆtypes.ts ã‚ˆã‚Šï¼‰
interface CharUnit {
  id: string;           // ä¾‹: phrase_0_word_1_char_2
  char: string;         // å®Ÿéš›ã®æ–‡å­—
  start: number;        // é–‹å§‹æ™‚é–“ï¼ˆmsï¼‰
  end: number;          // çµ‚äº†æ™‚é–“ï¼ˆmsï¼‰
  charIndex?: number;   // ãƒ•ãƒ¬ãƒ¼ã‚ºå†…ã§ã®æ–‡å­—ä½ç½®ï¼ˆ0ãƒ™ãƒ¼ã‚¹ï¼‰
  totalChars?: number;  // ãƒ•ãƒ¬ãƒ¼ã‚ºå†…ç·æ–‡å­—æ•°
  totalWords?: number;  // ãƒ•ãƒ¬ãƒ¼ã‚ºå†…ç·å˜èªæ•°
  pixiObj?: PIXI.Text;  // PIXIã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§
}
```

#### 2. æ–‡å­—ä½ç½®è¨ˆç®—ã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆWordSlideTextã‚ˆã‚Šï¼‰

```typescript
// åŠè§’ãƒ»å…¨è§’æ–‡å­—ã®åŒºåˆ¥ã¨é–“éš”èª¿æ•´
function isHalfWidthChar(char: string): boolean {
  const code = char.charCodeAt(0);
  return (code >= 0x0020 && code <= 0x007E) ||    // ASCIIè‹±æ•°å­—
         (code >= 0xFF61 && code <= 0xFF9F);       // åŠè§’ã‚«ã‚¿ã‚«ãƒŠ
}

// æ–‡å­—ã”ã¨ã®ä½ç½®è¨ˆç®—
renderWordContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType) {
  const fontSize = params.fontSize || 32;
  const charSpacing = params.charSpacing || 1.0;
  let cumulativeXOffset = 0;
  
  if (params.chars && Array.isArray(params.chars)) {
    params.chars.forEach((charData, index) => {
      const char = charData.char;
      
      // åŠè§’æ–‡å­—ã®é–“éš”èª¿æ•´ï¼ˆWordSlideTextãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
      const effectiveSpacing = isHalfWidthChar(char) ? charSpacing * 0.6 : charSpacing;
      
      // æ–‡å­—ã‚³ãƒ³ãƒ†ãƒŠã®ä½ç½®è¨­å®š
      charContainer.position.set(cumulativeXOffset, 0);
      
      // æ¬¡ã®æ–‡å­—ç”¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆæ›´æ–°
      cumulativeXOffset += fontSize * effectiveSpacing;
      
      // charIndexã¨totalCharsã®æ´»ç”¨
      const charIndex = charData.charIndex || 0;
      const totalChars = charData.totalChars || 1;
      const progress = totalChars > 1 ? charIndex / (totalChars - 1) : 0;
    });
  }
}
```

#### 3. å¤šæ®µãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã§ã®æ–‡å­—ã‚«ã‚¦ãƒ³ãƒˆï¼ˆMultiLineTextãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰

```typescript
// ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã«ã‚ˆã‚‹æ®µç®¡ç†
const global = (window as any);
if (!global.__MULTILINE_STATE__) {
  global.__MULTILINE_STATE__ = {
    lastPhraseEndMs: -1,
    currentLine: 0,
    phraseLineMap: new Map(),
    lineHistory: []
  };
}

// æ®µã®è‡ªå‹•å‰²ã‚Šå½“ã¦
renderPhraseContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType) {
  const lineResetInterval = params.lineResetInterval || 5000;
  const maxLines = params.maxLines || 8;
  
  let lineIndex = 0;
  if (global.__MULTILINE_STATE__.phraseLineMap.has(params.id)) {
    lineIndex = global.__MULTILINE_STATE__.phraseLineMap.get(params.id);
  } else {
    // æ–°ã—ã„æ®µã®å‰²ã‚Šå½“ã¦
    if (nowMs > global.__MULTILINE_STATE__.lastPhraseEndMs + lineResetInterval) {
      global.__MULTILINE_STATE__.currentLine = 0;
    }
    
    lineIndex = global.__MULTILINE_STATE__.currentLine % maxLines;
    global.__MULTILINE_STATE__.phraseLineMap.set(params.id, lineIndex);
    global.__MULTILINE_STATE__.currentLine = (lineIndex + 1) % maxLines;
  }
  
  // æ®µã«åŸºã¥ãç¸¦ä½ç½®ã®è¨ˆç®—
  const lineSpacing = params.lineSpacing || 60;
  const yOffset = lineIndex * lineSpacing;
  container.position.y = baseY + yOffset;
}
```

#### 4. æ–‡å­—é–“éš”ã®è©³ç´°åˆ¶å¾¡

```typescript
// é«˜åº¦ãªæ–‡å­—é–“éš”åˆ¶å¾¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
metadata: {
  params: [
    { name: "charSpacing", type: "number", default: 1.0, min: 0.1, max: 3.0, step: 0.1 },
    { name: "halfWidthRatio", type: "number", default: 0.6, min: 0.3, max: 1.0, step: 0.1 },
    { name: "wordSpacing", type: "number", default: 1.2, min: 0.5, max: 2.0, step: 0.1 },
    { name: "lineSpacing", type: "number", default: 60, min: 30, max: 120, step: 5 }
  ]
}

// å®Ÿè£…ã§ã®æ´»ç”¨
const calculateCharacterPosition = (charData, index, params) => {
  const fontSize = params.fontSize || 32;
  const baseSpacing = params.charSpacing || 1.0;
  const halfWidthRatio = params.halfWidthRatio || 0.6;
  
  let xOffset = 0;
  for (let i = 0; i < index; i++) {
    const prevChar = charData[i].char;
    const spacing = isHalfWidthChar(prevChar) ? 
      baseSpacing * halfWidthRatio : baseSpacing;
    xOffset += fontSize * spacing;
  }
  
  return xOffset;
};
```

#### 5. æ–‡å­—ã‚«ã‚¦ãƒ³ãƒˆãƒ™ãƒ¼ã‚¹ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

```typescript
// æ–‡å­—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚£ãƒ¬ã‚¤è¨ˆç®—
renderCharContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType) {
  const charIndex = params.charIndex || 0;
  const totalChars = params.totalChars || 1;
  const staggerDelay = params.charStaggerDelay || 50; // ms
  
  // æ–‡å­—ã”ã¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹æ™‚é–“
  const charStartMs = startMs + (charIndex * staggerDelay);
  const charEndMs = endMs + (charIndex * staggerDelay);
  
  // æ–‡å­—ä½ç½®ã«åŸºã¥ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆå¼·åº¦
  const normalizedIndex = totalChars > 1 ? charIndex / (totalChars - 1) : 0;
  const effectIntensity = 1.0 - Math.abs(normalizedIndex - 0.5) * 2; // ä¸­å¤®ã»ã©å¼·ã„
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®åˆ¤å®š
  let charPhase = 'in';
  if (nowMs >= charStartMs && nowMs <= charEndMs) {
    charPhase = 'active';
  } else if (nowMs > charEndMs) {
    charPhase = 'out';
  }
}
```

#### 6. å˜èªå¢ƒç•Œã®æ¤œå‡ºã¨å‡¦ç†

```typescript
// å˜èªå¢ƒç•Œã§ã®ç‰¹æ®Šå‡¦ç†
function isWordBoundary(char: string, nextChar: string): boolean {
  const isSpaceChar = /\s/.test(char);
  const isPunctuation = /[ã€‚ã€ï¼ï¼Ÿ,.!?]/.test(char);
  const isEnglish = /[a-zA-Z]/.test(char);
  const isNextEnglish = nextChar ? /[a-zA-Z]/.test(nextChar) : false;
  
  return isSpaceChar || isPunctuation || (isEnglish && !isNextEnglish);
}

// å˜èªå¢ƒç•Œã§ã®é–“éš”èª¿æ•´
renderWordContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType) {
  const wordSpacing = params.wordSpacing || 1.2;
  
  params.chars.forEach((charData, index) => {
    const nextCharData = params.chars[index + 1];
    const isLastInWord = isWordBoundary(charData.char, nextCharData?.char);
    
    if (isLastInWord && nextCharData) {
      // å˜èªé–“ã«è¿½åŠ ã‚¹ãƒšãƒ¼ã‚¹
      cumulativeXOffset += fontSize * (wordSpacing - charSpacing);
    }
  });
}
```

---

## PixiJSãƒ•ã‚£ãƒ«ã‚¿ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå®Ÿè£…

### é«˜åº¦ãªãƒ•ã‚£ãƒ«ã‚¿ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å®Ÿè£…

#### 1. Advanced Bloom Filterã®å®Ÿè£…ï¼ˆWordSlideTextãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰

```typescript
// ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
import { AdvancedBloomFilter } from '@pixi/filter-advanced-bloom';

// ãƒ•ã‚£ãƒ«ã‚¿ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å®šç¾©
metadata: {
  params: [
    { name: "enableGlow", type: "boolean", default: false },
    { name: "glowStrength", type: "number", default: 0.5, min: 0.1, max: 2.0, step: 0.1 },
    { name: "glowBrightness", type: "number", default: 1.0, min: 0.5, max: 2.0, step: 0.1 },
    { name: "glowBlur", type: "number", default: 2, min: 1, max: 10, step: 1 },
    { name: "glowQuality", type: "number", default: 4, min: 1, max: 8, step: 1 },
    { name: "glowThreshold", type: "number", default: 0.2, min: 0.0, max: 1.0, step: 0.05 }
  ]
}

// ãƒ•ã‚£ãƒ«ã‚¿ã®é©ç”¨ã¨FilterAreaç®¡ç†
applyBloomEffect(container: PIXI.Container, params: Record<string, any>): void {
  const enableGlow = params.enableGlow || false;
  
  if (enableGlow) {
    // æ—¢å­˜ãƒ•ã‚£ãƒ«ã‚¿ã®ç¢ºèª
    const hasBloomFilter = container.filters && 
      container.filters.some(filter => filter instanceof AdvancedBloomFilter);
    
    if (!hasBloomFilter) {
      const bloomFilter = new AdvancedBloomFilter({
        threshold: params.glowThreshold || 0.2,
        bloomScale: params.glowStrength || 0.5,
        brightness: params.glowBrightness || 1.0,
        blur: params.glowBlur || 2,
        quality: params.glowQuality || 4
      });
      
      container.filters = container.filters || [];
      container.filters.push(bloomFilter);
      
      // FilterAreaã®è¨­å®šï¼ˆã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°é˜²æ­¢ï¼‰
      const bounds = container.getBounds();
      const padding = params.glowBlur * 10 + 20; // ã‚°ãƒ­ãƒ¼ç¯„å›²ã‚’è€ƒæ…®
      container.filterArea = new PIXI.Rectangle(
        bounds.x - padding,
        bounds.y - padding,
        bounds.width + padding * 2,
        bounds.height + padding * 2
      );
    }
  } else {
    // ãƒ•ã‚£ãƒ«ã‚¿ã®å‰Šé™¤
    if (container.filters) {
      container.filters = container.filters.filter(
        filter => !(filter instanceof AdvancedBloomFilter)
      );
      if (container.filters.length === 0) {
        container.filters = null;
        container.filterArea = null;
      }
    }
  }
}
```

#### 2. ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ«ã‚¿ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å®Ÿè£…

```typescript
// ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ãƒ•ã‚£ãƒ«ã‚¿
class OutlineFilter extends PIXI.Filter {
  constructor(thickness: number = 1, color: number = 0x000000) {
    const vertex = `
      attribute vec2 aVertexPosition;
      attribute vec2 aTextureCoord;
      
      uniform mat3 projectionMatrix;
      
      varying vec2 vTextureCoord;
      
      void main(void) {
        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
      }
    `;
    
    const fragment = `
      varying vec2 vTextureCoord;
      uniform sampler2D uSampler;
      uniform float thickness;
      uniform vec3 outlineColor;
      uniform vec2 textureSize;
      
      void main(void) {
        vec4 ownColor = texture2D(uSampler, vTextureCoord);
        vec4 curColor;
        float maxAlpha = 0.0;
        vec2 displaced;
        
        for (float angle = 0.0; angle < 6.28; angle += 1.047) {
          displaced.x = vTextureCoord.x + thickness * cos(angle) / textureSize.x;
          displaced.y = vTextureCoord.y + thickness * sin(angle) / textureSize.y;
          curColor = texture2D(uSampler, displaced);
          maxAlpha = max(maxAlpha, curColor.a);
        }
        
        vec4 resultColor = vec4(outlineColor, maxAlpha);
        gl_FragColor = mix(resultColor, ownColor, ownColor.a);
      }
    `;
    
    super(vertex, fragment);
    
    this.uniforms.thickness = thickness;
    this.uniforms.outlineColor = new Float32Array([
      ((color >> 16) & 0xFF) / 255,
      ((color >> 8) & 0xFF) / 255,
      (color & 0xFF) / 255
    ]);
  }
}

// ãƒ•ã‚£ãƒ«ã‚¿ã®ä½¿ç”¨
const outlineFilter = new OutlineFilter(2, 0x000000);
container.filters = [outlineFilter];
```

#### 3. ãƒ•ã‚£ãƒ«ã‚¿ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

```typescript
// ãƒ•ã‚£ãƒ«ã‚¿ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨ãƒ—ãƒ¼ãƒ«ç®¡ç†
class FilterPool {
  private bloomFilters: AdvancedBloomFilter[] = [];
  
  getBloomFilter(config: any): AdvancedBloomFilter {
    let filter = this.bloomFilters.pop();
    if (!filter) {
      filter = new AdvancedBloomFilter(config);
    } else {
      // è¨­å®šã®æ›´æ–°
      Object.assign(filter, config);
    }
    return filter;
  }
  
  returnBloomFilter(filter: AdvancedBloomFilter): void {
    if (this.bloomFilters.length < 5) { // ãƒ—ãƒ¼ãƒ«ã‚µã‚¤ã‚ºåˆ¶é™
      this.bloomFilters.push(filter);
    } else {
      filter.destroy();
    }
  }
}

// ãƒ•ã‚£ãƒ«ã‚¿é©ç”¨æ™‚ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®
applyFiltersOptimized(container: PIXI.Container, params: Record<string, any>): void {
  const enableEffects = params.enableEffects || false;
  
  // è¡¨ç¤ºç¯„å›²å¤–ã®å ´åˆã¯ãƒ•ã‚£ãƒ«ã‚¿ã‚’ç„¡åŠ¹åŒ–
  if (!container.visible || container.alpha <= 0) {
    container.filters = null;
    return;
  }
  
  // å‹•çš„å“è³ªèª¿æ•´
  const app = (window as any).__PIXI_APP__;
  const fps = app?.ticker?.FPS || 60;
  const qualityMultiplier = fps > 45 ? 1.0 : 0.5; // FPSä½ä¸‹æ™‚ã«å“è³ªã‚’è½ã¨ã™
  
  if (enableEffects) {
    const adjustedQuality = Math.floor((params.glowQuality || 4) * qualityMultiplier);
    // ãƒ•ã‚£ãƒ«ã‚¿è¨­å®š...
  }
}
```

---

## ãƒ†ã‚¯ã‚¹ãƒãƒ£æ“ä½œã¨RenderTextureæ´»ç”¨

### RenderTextureã‚’æ´»ç”¨ã—ãŸé«˜åº¦ãªè¡¨ç¾

#### 1. GlitchTextã§ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ†å‰²æŠ€æ³•

```typescript
// ãƒ™ãƒ¼ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
createBaseTexture(text: string, style: PIXI.TextStyle): PIXI.RenderTexture {
  const app = (window as any).__PIXI_APP__;
  if (!app) throw new Error('PIXIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  
  // ãƒ™ãƒ¼ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã®ä½œæˆ
  const baseText = new PIXI.Text(text, style);
  baseText.anchor.set(0.5, 0.5);
  
  // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã®è¨ˆç®—ï¼ˆãƒ‘ãƒ‡ã‚£ãƒ³ã‚°è€ƒæ…®ï¼‰
  const bounds = baseText.getBounds();
  const padding = 10;
  const textWidth = bounds.width + padding * 2;
  const textHeight = bounds.height + padding * 2;
  
  // RenderTextureã®ä½œæˆ
  const renderTexture = PIXI.RenderTexture.create({
    width: Math.ceil(textWidth),
    height: Math.ceil(textHeight),
    resolution: 1
  });
  
  // ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸­å¤®ã«é…ç½®ã—ã¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  baseText.position.set(textWidth / 2, textHeight / 2);
  app.renderer.render(baseText, { renderTexture, clear: true });
  
  baseText.destroy(); // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢
  return renderTexture;
}

// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®åˆ†å‰²ã¨ã‚°ãƒªãƒƒãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
applyGlitchEffect(
  container: PIXI.Container,
  renderTexture: PIXI.RenderTexture,
  params: Record<string, any>
): void {
  const blockCount = params.glitchBlocks || 8;
  const intensity = params.glitchIntensity || 1.0;
  const colorShift = params.colorShift || 0.5;
  
  const textureWidth = renderTexture.width;
  const textureHeight = renderTexture.height;
  const blockHeight = textureHeight / blockCount;
  
  // ã‚·ãƒ¼ãƒ‰ä»˜ãä¹±æ•°ç”Ÿæˆå™¨ï¼ˆå†ç¾å¯èƒ½ãªã‚°ãƒªãƒƒãƒï¼‰
  const random = this.createSeededRandom(params.glitchSeed || 12345);
  
  for (let i = 0; i < blockCount; i++) {
    const y = i * blockHeight;
    const actualBlockHeight = Math.min(blockHeight, textureHeight - y);
    
    if (actualBlockHeight <= 0) break;
    
    // ã‚°ãƒªãƒƒãƒã®ç™ºç”Ÿç¢ºç‡
    if (random() > 0.3) continue;
    
    // ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä½œæˆï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã®éƒ¨åˆ†åˆ‡ã‚Šå‡ºã—ï¼‰
    const frame = new PIXI.Rectangle(0, y, textureWidth, actualBlockHeight);
    const blockTexture = new PIXI.Texture(renderTexture.baseTexture, frame);
    
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ä½œæˆ
    const sprite = new PIXI.Sprite(blockTexture);
    sprite.position.set(0, y);
    
    // ã‚°ãƒªãƒƒãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®é©ç”¨
    const offsetX = (random() - 0.5) * intensity * 20;
    const scaleX = 1 + (random() - 0.5) * intensity * 0.2;
    
    sprite.position.x += offsetX;
    sprite.scale.x = scaleX;
    
    // ã‚«ãƒ©ãƒ¼ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ã§RGBã‚·ãƒ•ãƒˆ
    if (colorShift > 0) {
      const colorMatrix = new PIXI.filters.ColorMatrixFilter();
      const shift = (random() - 0.5) * colorShift;
      colorMatrix.matrix = [
        1 + shift, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1 - shift, 0, 0,
        0, 0, 0, 1, 0
      ];
      sprite.filters = [colorMatrix];
    }
    
    container.addChild(sprite);
  }
}
```

#### 2. ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ™ãƒ¼ã‚¹ã®ãƒã‚¹ã‚¯å‡¦ç†

```typescript
// å††å½¢ãƒã‚¹ã‚¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ä½œæˆ
createCircularMask(radius: number): PIXI.RenderTexture {
  const size = radius * 2;
  const maskTexture = PIXI.RenderTexture.create({ width: size, height: size });
  
  const graphics = new PIXI.Graphics();
  graphics.beginFill(0xFFFFFF);
  graphics.drawCircle(radius, radius, radius);
  graphics.endFill();
  
  const app = (window as any).__PIXI_APP__;
  app.renderer.render(graphics, { renderTexture: maskTexture, clear: true });
  
  graphics.destroy();
  return maskTexture;
}

// ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒã‚¹ã‚¯ã®ä½œæˆ
createGradientMask(width: number, height: number, direction: string): PIXI.RenderTexture {
  const maskTexture = PIXI.RenderTexture.create({ width, height });
  
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d')!;
  
  let gradient: CanvasGradient;
  switch (direction) {
    case 'horizontal':
      gradient = ctx.createLinearGradient(0, 0, width, 0);
      break;
    case 'vertical':
      gradient = ctx.createLinearGradient(0, 0, 0, height);
      break;
    case 'radial':
    default:
      gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height)/2);
      break;
  }
  
  gradient.addColorStop(0, 'white');
  gradient.addColorStop(1, 'black');
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);
  
  const texture = PIXI.Texture.from(canvas);
  return PIXI.RenderTexture.from(texture);
}

// ãƒã‚¹ã‚¯ã®é©ç”¨
applyTextureBasedMask(target: PIXI.Container, maskTexture: PIXI.RenderTexture): void {
  const maskSprite = new PIXI.Sprite(maskTexture);
  target.mask = maskSprite;
  target.addChild(maskSprite); // ãƒã‚¹ã‚¯ã‚‚ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ ãŒå¿…è¦
}
```

#### 3. ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒˆãƒ©ã‚¹ã®åŠ¹ç‡çš„ãªç®¡ç†

```typescript
// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒˆãƒ©ã‚¹ç®¡ç†ã‚¯ãƒ©ã‚¹
class TextureAtlasManager {
  private atlas: PIXI.RenderTexture;
  private allocatedAreas: Map<string, PIXI.Rectangle> = new Map();
  private currentX = 0;
  private currentY = 0;
  private rowHeight = 0;
  private atlasSize = 1024;
  
  constructor(size: number = 1024) {
    this.atlasSize = size;
    this.atlas = PIXI.RenderTexture.create({
      width: size,
      height: size,
      resolution: 1
    });
  }
  
  // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç™»éŒ²
  addTexture(id: string, sourceTexture: PIXI.Texture): PIXI.Texture | null {
    const width = sourceTexture.width;
    const height = sourceTexture.height;
    
    // é ˜åŸŸã®ç¢ºä¿
    const area = this.allocateArea(width, height);
    if (!area) return null; // ã‚¢ãƒˆãƒ©ã‚¹ãŒãƒ•ãƒ«
    
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ã‚³ãƒ”ãƒ¼
    const sprite = new PIXI.Sprite(sourceTexture);
    sprite.position.set(area.x, area.y);
    
    const app = (window as any).__PIXI_APP__;
    app.renderer.render(sprite, {
      renderTexture: this.atlas,
      clear: false,
      transform: null
    });
    
    sprite.destroy();
    
    // æ–°ã—ã„ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ä½œæˆ
    const atlasTexture = new PIXI.Texture(this.atlas.baseTexture, area);
    this.allocatedAreas.set(id, area);
    
    return atlasTexture;
  }
  
  private allocateArea(width: number, height: number): PIXI.Rectangle | null {
    // è¡Œã«åã¾ã‚‰ãªã„å ´åˆã¯æ¬¡ã®è¡Œã¸
    if (this.currentX + width > this.atlasSize) {
      this.currentX = 0;
      this.currentY += this.rowHeight;
      this.rowHeight = 0;
    }
    
    // ã‚¢ãƒˆãƒ©ã‚¹ã«åã¾ã‚‰ãªã„å ´åˆ
    if (this.currentY + height > this.atlasSize) {
      return null;
    }
    
    const area = new PIXI.Rectangle(this.currentX, this.currentY, width, height);
    this.currentX += width;
    this.rowHeight = Math.max(this.rowHeight, height);
    
    return area;
  }
}
```

---

## FontServiceçµ±åˆã¨ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†

### Electronãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

#### 1. FontServiceã®çµ±åˆãƒ‘ã‚¿ãƒ¼ãƒ³

```typescript
// FontServiceã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¨åˆ©ç”¨
import { FontService } from '../../services/FontService';

// å‹•çš„ãƒ•ã‚©ãƒ³ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å®šç¾©
metadata: {
  params: [
    {
      name: "fontFamily",
      type: "string",
      default: "Arial",
      get options() {
        // å®Ÿè¡Œæ™‚ã«ã‚·ã‚¹ãƒ†ãƒ ãƒ•ã‚©ãƒ³ãƒˆã‚’å–å¾—
        return FontService.getAvailableFonts();
      }
    }
  ]
}

// ãƒ•ã‚©ãƒ³ãƒˆã®æ¤œè¨¼ã¨ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
validateAndSetFont(style: PIXI.TextStyle, requestedFont: string): void {
  const availableFonts = FontService.getAvailableFonts();
  const fontExists = availableFonts.some(font => font.value === requestedFont);
  
  if (fontExists) {
    style.fontFamily = requestedFont;
  } else {
    console.warn(`ãƒ•ã‚©ãƒ³ãƒˆ '${requestedFont}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚Arialã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚`);
    style.fontFamily = 'Arial';
  }
}
```

#### 2. ãƒ•ã‚©ãƒ³ãƒˆèª­ã¿è¾¼ã¿çŠ¶æ…‹ã®ç®¡ç†

```typescript
// ãƒ•ã‚©ãƒ³ãƒˆèª­ã¿è¾¼ã¿ç¢ºèª
async waitForFontLoad(fontFamily: string, timeout: number = 3000): Promise<boolean> {
  if (!document.fonts) return true; // ãƒ•ã‚©ãƒ³ãƒˆAPIãŒç„¡ã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
  
  try {
    await document.fonts.load(`16px "${fontFamily}"`);
    return document.fonts.check(`16px "${fontFamily}"`);
  } catch (error) {
    console.warn(`ãƒ•ã‚©ãƒ³ãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${fontFamily}`, error);
    return false;
  }
}

// ãƒ•ã‚©ãƒ³ãƒˆå¯¾å¿œãƒ†ã‚­ã‚¹ãƒˆä½œæˆ
async createTextWithFont(
  text: string,
  fontFamily: string,
  fontSize: number,
  color: string
): Promise<PIXI.Text> {
  
  // ãƒ•ã‚©ãƒ³ãƒˆèª­ã¿è¾¼ã¿ã‚’å¾…æ©Ÿ
  const fontLoaded = await this.waitForFontLoad(fontFamily);
  
  const style = new PIXI.TextStyle({
    fontFamily: fontLoaded ? fontFamily : 'Arial',
    fontSize: fontSize,
    fill: color,
    align: 'center'
  });
  
  const textObject = new PIXI.Text(text, style);
  
  // ãƒ•ã‚©ãƒ³ãƒˆèª­ã¿è¾¼ã¿å®Œäº†å¾Œã®å†æç”»
  if (!fontLoaded) {
    this.waitForFontLoad(fontFamily).then((loaded) => {
      if (loaded) {
        textObject.style.fontFamily = fontFamily;
        textObject.dirty = true; // å†æç”»ãƒ•ãƒ©ã‚°
      }
    });
  }
  
  return textObject;
}
```

#### 3. ãƒ•ã‚©ãƒ³ãƒˆãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨ˆç®—

```typescript
// æ–‡å­—ã®æ­£ç¢ºãªå¯¸æ³•è¨ˆç®—
calculateTextMetrics(text: string, style: PIXI.TextStyle): {
  width: number,
  height: number,
  baseline: number
} {
  const metrics = PIXI.TextMetrics.measureText(text, style);
  
  return {
    width: metrics.width,
    height: metrics.height,
    baseline: metrics.fontProperties.descent
  };
}

// è¡Œé«˜ã®è‡ªå‹•èª¿æ•´
calculateOptimalLineHeight(fontFamily: string, fontSize: number): number {
  const tempStyle = new PIXI.TextStyle({
    fontFamily: fontFamily,
    fontSize: fontSize
  });
  
  // æ¨™æº–çš„ãªæ–‡å­—ã§ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’æ¸¬å®š
  const metrics = PIXI.TextMetrics.measureText('AjyãŒ', tempStyle);
  const fontProperties = metrics.fontProperties;
  
  // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã¨ä¸‹é™éƒ¨ã‚’è€ƒæ…®ã—ãŸè¡Œé«˜
  return fontProperties.fontSize + fontProperties.descent * 0.2;
}
```

---

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æŠ€æ³•

### ç¾è¡Œã‚·ã‚¹ãƒ†ãƒ ã§å®Ÿè£…æ¸ˆã¿ã®æœ€é©åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³

#### 1. ã‚·ãƒ¼ãƒ‰ä»˜ãä¹±æ•°ç”Ÿæˆï¼ˆGlitchTextãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰

```typescript
// å†ç¾å¯èƒ½ãªä¹±æ•°ç”Ÿæˆå™¨
createSeededRandom(seed: number): () => number {
  let state = seed;
  return function() {
    state = (state * 1664525 + 1013904223) % 4294967296;
    return state / 4294967296;
  };
}

// ä½¿ç”¨ä¾‹ï¼šæ¯å›åŒã˜ã‚°ãƒªãƒƒãƒãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
const random = this.createSeededRandom(params.glitchSeed || 12345);
for (let i = 0; i < blockCount; i++) {
  if (random() > 0.3) continue; // åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—
  // ã‚°ãƒªãƒƒãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®é©ç”¨...
}
```

#### 2. ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã«ã‚ˆã‚‹åŠ¹ç‡çš„ãªçŠ¶æ…‹ç®¡ç†

```typescript
// ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã®æ´»ç”¨ï¼ˆMultiLineTextãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
const global = (window as any);
if (!global.__MULTILINE_STATE__) {
  global.__MULTILINE_STATE__ = {
    lastPhraseEndMs: -1,
    currentLine: 0,
    phraseLineMap: new Map(),
    lineHistory: [],
    stateVersion: 1
  };
}

// çŠ¶æ…‹å¤‰æ›´ã®æ¤œå‡ºã¨æœ€é©åŒ–
checkStateVersion(): boolean {
  const currentVersion = global.__MULTILINE_STATE__.stateVersion;
  if (this.lastKnownVersion !== currentVersion) {
    this.lastKnownVersion = currentVersion;
    return true; // å†è¨ˆç®—ãŒå¿…è¦
  }
  return false; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ©ç”¨å¯èƒ½
}
```

#### 3. ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³

```typescript
// å†åˆ©ç”¨å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«
class ObjectPool<T> {
  private objects: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  private maxSize: number;
  
  constructor(createFn: () => T, resetFn: (obj: T) => void, maxSize: number = 50) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.maxSize = maxSize;
  }
  
  get(): T {
    const obj = this.objects.pop();
    if (obj) {
      this.resetFn(obj);
      return obj;
    }
    return this.createFn();
  }
  
  return(obj: T): void {
    if (this.objects.length < this.maxSize) {
      this.objects.push(obj);
    } else {
      // ãƒ—ãƒ¼ãƒ«ãŒæº€æ¯ã®å ´åˆã¯ç ´æ£„
      if ((obj as any).destroy) {
        (obj as any).destroy();
      }
    }
  }
}

// ä½¿ç”¨ä¾‹ï¼šã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«
const graphicsPool = new ObjectPool(
  () => new PIXI.Graphics(),
  (graphics) => graphics.clear(),
  20
);

// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå†…ã§ã®ä½¿ç”¨
renderCharContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType) {
  const circle = graphicsPool.get();
  circle.lineStyle(lineWidth, color);
  circle.drawCircle(0, 0, radius);
  container.addChild(circle);
  
  // å¾Œã§ãƒ—ãƒ¼ãƒ«ã«è¿”å´
  // cleanupæ™‚: graphicsPool.return(circle);
}
```

#### 4. ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆé©å¿œå“è³ªåˆ¶å¾¡

```typescript
// å‹•çš„å“è³ªèª¿æ•´ã‚·ã‚¹ãƒ†ãƒ 
class AdaptiveQualityManager {
  private targetFPS = 60;
  private qualityLevel = 1.0;
  private frameTimeHistory: number[] = [];
  private maxHistorySize = 30;
  
  updateFrameTime(deltaTime: number): void {
    this.frameTimeHistory.push(deltaTime);
    if (this.frameTimeHistory.length > this.maxHistorySize) {
      this.frameTimeHistory.shift();
    }
    
    // å¹³å‡ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“ã‹ã‚‰å“è³ªã‚’èª¿æ•´
    const avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
    const currentFPS = 1000 / avgFrameTime;
    
    if (currentFPS < this.targetFPS * 0.8) {
      this.qualityLevel = Math.max(0.3, this.qualityLevel - 0.1);
    } else if (currentFPS > this.targetFPS * 0.95) {
      this.qualityLevel = Math.min(1.0, this.qualityLevel + 0.05);
    }
  }
  
  getQualityLevel(): number {
    return this.qualityLevel;
  }
}

// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå†…ã§ã®é©ç”¨
renderWithAdaptiveQuality(container: PIXI.Container, params: Record<string, any>): void {
  const qualityLevel = this.qualityManager.getQualityLevel();
  
  // å“è³ªã«å¿œã˜ã¦ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’èª¿æ•´
  const effectIntensity = params.effectIntensity * qualityLevel;
  const particleCount = Math.floor(params.particleCount * qualityLevel);
  const filterQuality = Math.max(1, Math.floor(params.filterQuality * qualityLevel));
  
  // ä½å“è³ªæ™‚ã¯ä¸€éƒ¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç„¡åŠ¹åŒ–
  if (qualityLevel < 0.5) {
    container.filters = null;
  }
}
```

#### 5. åŠ¹ç‡çš„ãªå¢ƒç•Œæ¤œå‡ºã¨è¡¨ç¤ºç¯„å›²æœ€é©åŒ–

```typescript
// è¡¨ç¤ºç¯„å›²ã®äº‹å‰è¨ˆç®—
calculateVisibilityBounds(container: PIXI.Container): {
  isVisible: boolean,
  intersectionRatio: number
} {
  const app = (window as any).__PIXI_APP__;
  if (!app) return { isVisible: true, intersectionRatio: 1.0 };
  
  const bounds = container.getBounds();
  const screenBounds = new PIXI.Rectangle(0, 0, app.screen.width, app.screen.height);
  
  // ç”»é¢å¤–åˆ¤å®š
  if (bounds.right < 0 || bounds.left > screenBounds.width ||
      bounds.bottom < 0 || bounds.top > screenBounds.height) {
    return { isVisible: false, intersectionRatio: 0 };
  }
  
  // äº¤å·®ç‡ã®è¨ˆç®—
  const intersectionArea = Math.max(0,
    Math.min(bounds.right, screenBounds.right) - Math.max(bounds.left, screenBounds.left)
  ) * Math.max(0,
    Math.min(bounds.bottom, screenBounds.bottom) - Math.max(bounds.top, screenBounds.top)
  );
  
  const boundsArea = bounds.width * bounds.height;
  const intersectionRatio = boundsArea > 0 ? intersectionArea / boundsArea : 0;
  
  return {
    isVisible: intersectionRatio > 0.01, // 1%ä»¥ä¸Šè¦‹ãˆã¦ã„ã‚‹å ´åˆã®ã¿æç”»
    intersectionRatio
  };
}

// è¡¨ç¤ºæœ€é©åŒ–ã®é©ç”¨
optimizeVisualElements(container: PIXI.Container, params: Record<string, any>): void {
  const visibility = this.calculateVisibilityBounds(container);
  
  if (!visibility.isVisible) {
    container.visible = false;
    return;
  }
  
  container.visible = true;
  
  // éƒ¨åˆ†çš„ã«è¦‹ãˆã¦ã„ã‚‹å ´åˆã®è©³ç´°åº¦èª¿æ•´
  if (visibility.intersectionRatio < 0.5) {
    // LOD (Level of Detail) ã®é©ç”¨
    const simplifiedMode = true;
    this.renderWithLOD(container, params, simplifiedMode);
  } else {
    this.renderWithLOD(container, params, false);
  }
}
```

---

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ‡ãƒãƒƒã‚°

### å …ç‰¢ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³

#### 1. æ®µéšçš„ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†

```typescript
// é«˜åº¦ãªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° â†’ åŸºæœ¬ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° â†’ æœ€å°é™ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
renderCharContainer(
  container: PIXI.Container,
  text: string,
  params: Record<string, any>,
  nowMs: number,
  startMs: number,
  endMs: number,
  phase: AnimationPhase,
  hierarchyType: HierarchyType
): boolean {
  try {
    // é«˜åº¦ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆä»˜ããƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    return this.renderAdvancedCharacter(container, text, params, nowMs, startMs, endMs, phase);
  } catch (error) {
    console.warn('é«˜åº¦ãªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚åŸºæœ¬ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™:', error);
    
    try {
      // åŸºæœ¬çš„ãªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      return this.renderBasicCharacter(container, text, params, nowMs, startMs, endMs, phase);
    } catch (fallbackError) {
      console.error('åŸºæœ¬ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚‚å¤±æ•—ã—ã¾ã—ãŸã€‚æœ€å°é™ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’å®Ÿè¡Œã—ã¾ã™:', fallbackError);
      
      try {
        // æœ€å°é™ã®ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
        return this.renderMinimalCharacter(container, text, params);
      } catch (minimalError) {
        console.error('ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãŒå®Œå…¨ã«å¤±æ•—ã—ã¾ã—ãŸ:', minimalError);
        return false;
      }
    }
  }
}

// æœ€å°é™ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Ÿè£…
renderMinimalCharacter(
  container: PIXI.Container,
  text: string,
  params: Record<string, any>
): boolean {
  const fontSize = Math.max(12, Math.min(72, params.fontSize || 32));
  const color = params.activeTextColor || '#FFFFFF';
  
  const style = new PIXI.TextStyle({
    fontFamily: 'Arial', // ç¢ºå®Ÿã«å­˜åœ¨ã™ã‚‹ãƒ•ã‚©ãƒ³ãƒˆ
    fontSize: fontSize,
    fill: color
  });
  
  const textObj = new PIXI.Text(text, style);
  textObj.anchor.set(0.5, 0.5);
  container.addChild(textObj);
  
  return true;
}
```

#### 2. ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã¨ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢

```typescript
// ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã‚¯ãƒ©ã‚¹
class ResourceManager {
  private resources: Set<PIXI.DisplayObject> = new Set();
  private textures: Set<PIXI.Texture> = new Set();
  private renderTextures: Set<PIXI.RenderTexture> = new Set();
  
  register(resource: PIXI.DisplayObject | PIXI.Texture | PIXI.RenderTexture): void {
    if (resource instanceof PIXI.DisplayObject) {
      this.resources.add(resource);
    } else if (resource instanceof PIXI.RenderTexture) {
      this.renderTextures.add(resource);
    } else if (resource instanceof PIXI.Texture) {
      this.textures.add(resource);
    }
  }
  
  cleanup(): void {
    // DisplayObjectsã®ç ´æ£„
    this.resources.forEach(resource => {
      try {
        if (resource.parent) {
          resource.parent.removeChild(resource);
        }
        resource.destroy({ children: true });
      } catch (error) {
        console.warn('ãƒªã‚½ãƒ¼ã‚¹ç ´æ£„ã‚¨ãƒ©ãƒ¼:', error);
      }
    });
    
    // RenderTexturesã®ç ´æ£„
    this.renderTextures.forEach(texture => {
      try {
        texture.destroy(true);
      } catch (error) {
        console.warn('RenderTextureç ´æ£„ã‚¨ãƒ©ãƒ¼:', error);
      }
    });
    
    // é€šå¸¸ã®Texturesã®ç ´æ£„
    this.textures.forEach(texture => {
      try {
        if (texture.destroyBase !== false) {
          texture.destroy();
        }
      } catch (error) {
        console.warn('Textureç ´æ£„ã‚¨ãƒ©ãƒ¼:', error);
      }
    });
    
    this.resources.clear();
    this.textures.clear();
    this.renderTextures.clear();
  }
}

// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå†…ã§ã®ä½¿ç”¨
export const YourTemplate: IAnimationTemplate = {
  private resourceManager: ResourceManager = new ResourceManager();
  
  removeVisualElements(container: PIXI.Container): void {
    // ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ä»˜ãã®è¦ç´ å‰Šé™¤
    container.children.forEach(child => {
      if (!(child instanceof PIXI.Container) || 
          !(child as any).name?.includes('_container_')) {
        this.resourceManager.register(child);
      }
    });
    
    // æ¨™æº–çš„ãªå‰Šé™¤å‡¦ç†
    this.standardRemoveVisualElements(container);
    
    // ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    this.resourceManager.cleanup();
  }
};
```

#### 3. ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®åŠ¹ç‡çš„ãªç®¡ç†

```typescript
// ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
class DebugLogger {
  private static instance: DebugLogger;
  private logBuffer: Array<{timestamp: number, level: string, message: string}> = [];
  private maxBufferSize = 1000;
  private logLevel: 'error' | 'warn' | 'info' | 'debug' = 'warn';
  
  static getInstance(): DebugLogger {
    if (!DebugLogger.instance) {
      DebugLogger.instance = new DebugLogger();
    }
    return DebugLogger.instance;
  }
  
  setLogLevel(level: 'error' | 'warn' | 'info' | 'debug'): void {
    this.logLevel = level;
  }
  
  log(level: 'error' | 'warn' | 'info' | 'debug', message: string, data?: any): void {
    if (this.shouldLog(level)) {
      const timestamp = performance.now();
      this.logBuffer.push({ timestamp, level, message });
      
      if (this.logBuffer.length > this.maxBufferSize) {
        this.logBuffer.shift();
      }
      
      console[level](`[${level.toUpperCase()}] ${message}`, data || '');
    }
  }
  
  private shouldLog(level: string): boolean {
    const levels = ['error', 'warn', 'info', 'debug'];
    return levels.indexOf(level) <= levels.indexOf(this.logLevel);
  }
  
  exportLogs(): string {
    return this.logBuffer.map(log => 
      `${log.timestamp.toFixed(2)}ms [${log.level}] ${log.message}`
    ).join('\n');
  }
}

// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå†…ã§ã®ä½¿ç”¨
animateContainer(container, text, params, nowMs, startMs, endMs, hierarchyType, phase) {
  const logger = DebugLogger.getInstance();
  
  logger.log('debug', `ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹: ${hierarchyType}`, {
    text, nowMs, startMs, endMs, phase
  });
  
  try {
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†...
    const result = this.performAnimation(container, text, params, nowMs, startMs, endMs, hierarchyType, phase);
    
    logger.log('debug', `ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†: ${hierarchyType}`);
    return result;
  } catch (error) {
    logger.log('error', `ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: ${hierarchyType}`, error);
    return false;
  }
}
```

#### 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã¨ã‚¢ãƒ©ãƒ¼ãƒˆ

```typescript
// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 
class PerformanceMonitor {
  private frameTimeHistory: number[] = [];
  private maxHistorySize = 60; // 1ç§’åˆ†ã®ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆ60FPSæƒ³å®šï¼‰
  private alertThreshold = 33.33; // 30FPSä»¥ä¸‹ã§ã‚¢ãƒ©ãƒ¼ãƒˆ
  private memoryUsageHistory: number[] = [];
  
  recordFrameTime(deltaTime: number): void {
    this.frameTimeHistory.push(deltaTime);
    if (this.frameTimeHistory.length > this.maxHistorySize) {
      this.frameTimeHistory.shift();
    }
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®è¨˜éŒ²ï¼ˆå®šæœŸçš„ã«ï¼‰
    if (this.frameTimeHistory.length % 30 === 0) {
      this.recordMemoryUsage();
    }
    
    this.checkPerformanceAlerts();
  }
  
  private recordMemoryUsage(): void {
    if ((performance as any).memory) {
      const memoryInfo = (performance as any).memory;
      const usageRatio = memoryInfo.usedJSHeapSize / memoryInfo.jsHeapSizeLimit;
      this.memoryUsageHistory.push(usageRatio);
      
      if (this.memoryUsageHistory.length > 20) { // æœ€æ–°20ä»¶ã®ã¿ä¿æŒ
        this.memoryUsageHistory.shift();
      }
    }
  }
  
  private checkPerformanceAlerts(): void {
    if (this.frameTimeHistory.length < 10) return;
    
    const recentFrames = this.frameTimeHistory.slice(-10);
    const avgFrameTime = recentFrames.reduce((a, b) => a + b, 0) / recentFrames.length;
    
    if (avgFrameTime > this.alertThreshold) {
      console.warn(`ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è­¦å‘Š: å¹³å‡ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“ ${avgFrameTime.toFixed(2)}ms (${(1000/avgFrameTime).toFixed(1)}FPS)`);
    }
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯
    const currentMemoryUsage = this.memoryUsageHistory[this.memoryUsageHistory.length - 1];
    if (currentMemoryUsage && currentMemoryUsage > 0.85) {
      console.warn(`ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡è­¦å‘Š: ${(currentMemoryUsage * 100).toFixed(1)}%`);
    }
  }
  
  getPerformanceReport(): {
    averageFPS: number,
    memoryUsage: number,
    frameTimeVariance: number
  } {
    if (this.frameTimeHistory.length === 0) {
      return { averageFPS: 0, memoryUsage: 0, frameTimeVariance: 0 };
    }
    
    const avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
    const variance = this.frameTimeHistory.reduce((acc, time) => {
      return acc + Math.pow(time - avgFrameTime, 2);
    }, 0) / this.frameTimeHistory.length;
    
    return {
      averageFPS: 1000 / avgFrameTime,
      memoryUsage: this.memoryUsageHistory[this.memoryUsageHistory.length - 1] || 0,
      frameTimeVariance: variance
    };
  }
}
```

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"id": "1", "content": "Update template guide header and version info", "status": "completed", "priority": "high"}, {"id": "2", "content": "Add current character/word counting implementation patterns", "status": "completed", "priority": "high"}, {"id": "3", "content": "Add PixiJS filter implementation guidelines", "status": "completed", "priority": "high"}, {"id": "4", "content": "Add texture manipulation and RenderTexture techniques", "status": "completed", "priority": "high"}, {"id": "5", "content": "Update interface definitions to match current types", "status": "in_progress", "priority": "medium"}, {"id": "6", "content": "Add FontService integration patterns", "status": "completed", "priority": "medium"}, {"id": "7", "content": "Add performance optimization techniques", "status": "completed", "priority": "medium"}, {"id": "8", "content": "Add error handling and debugging guidelines", "status": "completed", "priority": "low"}]

### ğŸ†• æ”¹å–„ã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­è¨ˆåŸå‰‡

#### 1. éšå±¤ç¶™æ‰¿ã‚’è€ƒæ…®ã—ãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å®šç¾©ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
```typescript
metadata: {
  params: [
    // åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå…¨éšå±¤ã§æœ‰åŠ¹ï¼‰
    { name: "fontSize", type: "number", default: 32, min: 12, max: 128, step: 1 },
    { name: "fontFamily", type: "string", default: "Arial" },
    
    // ğŸ†• çŠ¶æ…‹åˆ¥è‰²è¨­å®šï¼ˆFadeSlideTextãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
    { name: "defaultTextColor", type: "color", default: "#808080" },     // éã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚
    { name: "activeTextColor", type: "color", default: "#FF0000" },      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚  
    { name: "completedTextColor", type: "color", default: "#800000" },   // å®Œäº†æ™‚
    
    // ğŸ†• ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ï¼ˆç¶™æ‰¿å¯èƒ½ã€å®Ÿè£…æ¸ˆã¿ï¼‰
    { name: "headTime", type: "number", default: 500, min: 0, max: 2000, step: 50 },
    { name: "tailTime", type: "number", default: 500, min: 0, max: 2000, step: 50 },
    { name: "initialSpeed", type: "number", default: 0.1, min: 0.01, max: 1.0, step: 0.01 },
    { name: "activeSpeed", type: "number", default: 0.01, min: 0.001, max: 0.1, step: 0.001 },
    
    // ğŸ†• éšå±¤åˆ¥ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆå­è¦ç´ ã§ã®å¾®èª¿æ•´ç”¨ï¼‰
    { name: "phraseOffsetX", type: "number", default: 0, min: -200, max: 200, step: 1 },
    { name: "wordOffsetX", type: "number", default: 0, min: -100, max: 100, step: 1 },
    { name: "charOffsetX", type: "number", default: 0, min: -50, max: 50, step: 1 },
    
    // ğŸ†• è¦–è¦šè¦ç´ åˆ¶å¾¡ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
    { name: "circleSize", type: "number", default: 40, min: 10, max: 200, step: 1 },
    { name: "circleLineWidth", type: "number", default: 8, min: 1, max: 20, step: 1 },
    { name: "circleOpacity", type: "number", default: 1.0, min: 0.0, max: 1.0, step: 0.01 },
    
    // ğŸ†• ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆåˆ¶å¾¡ï¼ˆé‡è¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ - å¼·åˆ¶ä¿æŒå¯¾è±¡ï¼‰
    { name: "charSpacing", type: "number", default: 1.0, min: 0.1, max: 3.0, step: 0.1 },
    { name: "rightOffset", type: "number", default: 100, min: 0, max: 500, step: 10 },
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é–¢é€£
    { name: "debugMode", type: "boolean", default: false }
  ]
}
```

#### 2. ğŸ†• æ”¹å–„ã•ã‚ŒãŸéšå±¤ç¶™æ‰¿ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³
```typescript
// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå†…ã§ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
animateContainer(container, text, params, nowMs, startMs, endMs, hierarchyType, phase) {
  // åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå…¨éšå±¤å…±é€šï¼‰
  const fontSize = params.fontSize || 32;
  const fontFamily = params.fontFamily || 'Arial';
  
  // ğŸ†• çŠ¶æ…‹åˆ¥è‰²è¨­å®šã®å–å¾—
  const defaultTextColor = params.defaultTextColor || '#808080';
  const activeTextColor = params.activeTextColor || '#FF0000';
  const completedTextColor = params.completedTextColor || '#800000';
  
  // ğŸ†• éšå±¤åˆ¥ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  let offsetX = 0;
  switch (hierarchyType) {
    case 'phrase':
      offsetX = params.phraseOffsetX || 0;
      break;
    case 'word':
      offsetX = params.wordOffsetX || 0;
      break;
    case 'char':
      offsetX = params.charOffsetX || 0;
      break;
  }
  
  // ğŸ†• ãƒ•ãƒ¬ãƒ¼ã‚ºã‹ã‚‰ã®ç¶™æ‰¿æƒ…å ±ï¼ˆå®Ÿè£…æ¸ˆã¿æ©Ÿèƒ½ï¼‰
  const phrasePhase = params.phrasePhase || phase;
  const phraseStartMs = params.phraseStartMs || startMs;
  const phraseEndMs = params.phraseEndMs || endMs;
  
  // ğŸ†• ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
  const headTime = params.headTime || 500;
  const tailTime = params.tailTime || 500;
  const initialSpeed = params.initialSpeed || 0.1;
  const activeSpeed = params.activeSpeed || 0.01;
  
  // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®ã€åˆ¶é™ä»˜ããƒ­ã‚°ï¼‰
  if (params.debugMode && nowMs % 1000 < 16) {  // 1ç§’ã«1å›ç¨‹åº¦
    console.log(`[${hierarchyType}] Phase: ${phase}, Offset: ${offsetX}, Speed: ${phase === 'active' ? activeSpeed : initialSpeed}`);
  }
}
```

---

## éšå±¤å¯¾å¿œã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…

### ã‚¹ãƒ†ãƒƒãƒ— 1: removeVisualElements ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ï¼ˆå¿…é ˆï¼‰

**é‡è¦**: éšå±¤æ§‹é€ ã‚’ä¿æŒã—ãªãŒã‚‰è¡¨ç¤ºè¦ç´ ã®ã¿ã‚’æ›´æ–°ã™ã‚‹ãŸã‚å¿…é ˆå®Ÿè£…

```typescript
// ğŸ†• å®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ãæ¨™æº–å®Ÿè£…
removeVisualElements(container: PIXI.Container): void {
  const childrenToKeep: PIXI.DisplayObject[] = [];
  const childrenToRemove: PIXI.DisplayObject[] = [];
  
  container.children.forEach(child => {
    // éšå±¤æ§‹é€ ã‚³ãƒ³ãƒ†ãƒŠã¯ä¿æŒï¼ˆåå‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã§åˆ¤å®šï¼‰
    if (child instanceof PIXI.Container && 
        (child as any).name && 
        ((child as any).name.includes('phrase_container_') || 
         (child as any).name.includes('word_container_') || 
         (child as any).name.includes('char_container_'))) {
      childrenToKeep.push(child);
    } else {
      // è¡¨ç¤ºè¦ç´ ï¼ˆGraphics, Textãªã©ï¼‰ã¯å‰Šé™¤å¯¾è±¡
      childrenToRemove.push(child);
    }
  });
  
  // è¡¨ç¤ºè¦ç´ ã®ã¿ã‚’å‰Šé™¤
  childrenToRemove.forEach(child => {
    container.removeChild(child);
    if (child instanceof PIXI.Container) {
      child.destroy({ children: true });
    } else {
      child.destroy();
    }
  });
}
```

### ã‚¹ãƒ†ãƒƒãƒ— 2: ğŸ†• animateContainer ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ï¼ˆå¿…é ˆï¼‰

```typescript
// ğŸ†• å®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ãæ¨™æº–å®Ÿè£…
animateContainer(
  container: PIXI.Container,
  text: string | string[],
  params: Record<string, any>,
  nowMs: number,
  startMs: number,
  endMs: number,
  hierarchyType: HierarchyType,
  phase: AnimationPhase
): boolean {
  
  // ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†
  const textContent = Array.isArray(text) ? text.join('') : text;
  
  // å¯è¦–æ€§è¨­å®š
  container.visible = true;
  
  // è¡¨ç¤ºè¦ç´ ã®å‰Šé™¤ï¼ˆéšå±¤æ§‹é€ ã¯ç¶­æŒï¼‰
  this.removeVisualElements!(container);
  
  // ğŸ†• éšå±¤åˆ¥å‡¦ç†ã®åˆ†å²ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  switch (hierarchyType) {
    case 'phrase':
      return this.renderPhraseContainer!(container, textContent, params, nowMs, startMs, endMs, phase, hierarchyType);
    case 'word':
      return this.renderWordContainer!(container, textContent, params, nowMs, startMs, endMs, phase, hierarchyType);
    case 'char':
      return this.renderCharContainer!(container, textContent, params, nowMs, startMs, endMs, phase, hierarchyType);
    default:
      console.warn(`æœªçŸ¥ã®éšå±¤ã‚¿ã‚¤ãƒ—: ${hierarchyType}`);
      return false;
  }
}
```

### ã‚¹ãƒ†ãƒƒãƒ— 3: éšå±¤åˆ¥ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Ÿè£…ï¼ˆFadeSlideTextãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ï¼‰

#### ğŸ†• ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ¬ãƒ™ãƒ«ã®å®Ÿè£…ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
```typescript
renderPhraseContainer(
  container: PIXI.Container,
  text: string,
  params: Record<string, any>,
  nowMs: number,
  startMs: number,
  endMs: number,
  phase: AnimationPhase,
  hierarchyType: HierarchyType
): boolean {
  
  // ğŸ†• ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ¬ãƒ™ãƒ«ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  const headTime = params.headTime || 500;
  const tailTime = params.tailTime || 500;
  const phraseOffsetX = params.phraseOffsetX || 0;
  const initialSpeed = params.initialSpeed || 0.1;
  const activeSpeed = params.activeSpeed || 0.01;
  const rightOffset = params.rightOffset || 100;
  
  // ğŸ†• PIXIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±ã®å–å¾—ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  const app = (window as any).__PIXI_APP__;
  if (!app || !app.renderer) {
    console.warn('PIXIã‚¢ãƒ—ãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    container.position.set(0, 0);
    return true;
  }
  
  const screenWidth = app.renderer.width;
  const screenHeight = app.renderer.height;
  const centerY = screenHeight / 2;
  const startPositionX = screenWidth + rightOffset;
  
  // ğŸ†• æ™‚é–“è¨ˆç®—ï¼ˆæ‹¡å¼µã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æœŸé–“ã‚’å«ã‚€ã€å®Ÿè£…æ¸ˆã¿ï¼‰
  const inStartTime = startMs - headTime;
  const outEndTime = endMs + tailTime;
  
  // ğŸ†• æ®µéšçš„ãƒ•ã‚§ãƒ¼ã‚ºåˆ¤å®šï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  let actualPhase = phase;
  if (nowMs < inStartTime) {
    actualPhase = 'in';
  } else if (nowMs > outEndTime) {
    actualPhase = 'out';
  } else if (nowMs >= startMs && nowMs <= endMs) {
    actualPhase = 'active';
  }
  
  // ğŸ†• ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ¬ãƒ™ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨ˆç®—ï¼ˆFadeSlideTextãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  let posX = startPositionX;
  let alpha = 1.0;
  
  if (nowMs < inStartTime) {
    // å…¥å ´å‰ï¼šåˆæœŸä½ç½®ã§éè¡¨ç¤º
    posX = startPositionX;
    alpha = 0;
  } else if (nowMs < startMs) {
    // å…¥å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼šå³ã‹ã‚‰ä¸­å¤®ã¸ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ä»˜ãï¼‰
    const progress = (nowMs - inStartTime) / headTime;
    const easedProgress = this.easeOutCubic(progress);  // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°
    posX = startPositionX - (startPositionX - screenWidth/2) * easedProgress;
    alpha = progress;
  } else if (nowMs <= endMs) {
    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ï¼šä¸­å¤®ã‹ã‚‰å·¦ã¸ã‚†ã£ãã‚Šç§»å‹•
    const activeTime = nowMs - startMs;
    posX = screenWidth/2 - activeTime * activeSpeed;
    alpha = 1.0;
  } else if (nowMs < outEndTime) {
    // é€€å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼šå·¦æ–¹å‘ã«åŠ é€Ÿ
    const exitProgress = (nowMs - endMs) / tailTime;
    const easedProgress = this.easeInCubic(exitProgress);  // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°
    const activeTime = endMs - startMs;
    const basePos = screenWidth/2 - activeTime * activeSpeed;
    posX = basePos - easedProgress * activeSpeed * tailTime * (initialSpeed / activeSpeed);
    alpha = 1.0 - exitProgress;
  } else {
    // é€€å ´å¾Œï¼šéè¡¨ç¤º
    alpha = 0;
  }
  
  // ãƒ•ãƒ¬ãƒ¼ã‚ºå…¨ä½“ã®ç§»å‹•ã¨ãƒ•ã‚§ãƒ¼ãƒ‰
  container.position.x = posX + phraseOffsetX;
  container.position.y = centerY;
  container.alpha = alpha;
  
  // é‡è¦: å­ã‚³ãƒ³ãƒ†ãƒŠã®å¤‰æ›è¡Œåˆ—ã‚’æ›´æ–°
  container.updateTransform();
  
  // ğŸ†• ãƒ‡ãƒãƒƒã‚°æƒ…å ±ï¼ˆåˆ¶é™ä»˜ãã€å®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  if (params.debugMode && nowMs % 1000 < 16) {
    console.log(`ãƒ•ãƒ¬ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠ: phase=${actualPhase}, pos=${posX}, alpha=${alpha}`);
  }
  
  return true;
}

// ğŸ†• ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
private easeOutCubic(t: number): number {
  return 1 - Math.pow(1 - t, 3);
}

private easeInCubic(t: number): number {
  return t * t * t;
}
```

#### ğŸ†• å˜èªãƒ¬ãƒ™ãƒ«ã®å®Ÿè£…ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
```typescript
renderWordContainer(
  container: PIXI.Container,
  text: string,
  params: Record<string, any>,
  nowMs: number,
  startMs: number,
  endMs: number,
  phase: AnimationPhase,
  hierarchyType: HierarchyType
): boolean {
  
  // ğŸ†• å˜èªãƒ¬ãƒ™ãƒ«ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  const wordOffsetX = params.wordOffsetX || 0;
  const wordOffsetY = params.wordOffsetY || 0;
  const fontSize = params.fontSize || 32;
  const charSpacing = params.charSpacing || 1.0;
  
  // ğŸ†• ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ•ã‚§ãƒ¼ã‚ºã‚’è€ƒæ…®ã—ãŸè¡¨ç¤ºåˆ¶å¾¡ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  const phrasePhase = params.phrasePhase || phase;
  const phraseStartMs = params.phraseStartMs || startMs;
  const phraseEndMs = params.phraseEndMs || endMs;
  const headTime = params.headTime || 500;
  const tailTime = params.tailTime || 500;
  
  // ãƒ•ãƒ¬ãƒ¼ã‚ºãŒè¡¨ç¤ºæœŸé–“å¤–ã®å ´åˆã¯éè¡¨ç¤º
  const phraseInStartTime = phraseStartMs - headTime;
  const phraseOutEndTime = phraseEndMs + tailTime;
  
  if (nowMs < phraseInStartTime || nowMs > phraseOutEndTime) {
    container.visible = false;
    return true;
  }
  
  // å˜èªã‚³ãƒ³ãƒ†ãƒŠã¯å¸¸ã«ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã®åŸç‚¹ã«é…ç½®
  container.position.set(wordOffsetX, wordOffsetY);
  container.visible = true;
  
  // ğŸ†• æ–‡å­—ã‚³ãƒ³ãƒ†ãƒŠã®ç®¡ç†ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  if (params.chars && Array.isArray(params.chars)) {
    params.chars.forEach((charData, index) => {
      // æ—¢å­˜ã®æ–‡å­—ã‚³ãƒ³ãƒ†ãƒŠã‚’æ¤œç´¢
      let charContainer: PIXI.Container | null = null;
      
      container.children.forEach(child => {
        if (child instanceof PIXI.Container && 
            (child as any).name === `char_container_${charData.id}`) {
          charContainer = child as PIXI.Container;
        }
      });
      
      // å­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆ
      if (!charContainer) {
        charContainer = new PIXI.Container();
        (charContainer as any).name = `char_container_${charData.id}`;
        container.addChild(charContainer);
      }
      
      // æ–‡å­—ã‚³ãƒ³ãƒ†ãƒŠã®ä½ç½®è¨­å®š
      const charIndex = charData.charIndex || 0;
      const xOffset = charIndex * fontSize * charSpacing;
      charContainer.position.set(xOffset, 0);
      
      // ğŸ†• æ–‡å­—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®é©ç”¨ï¼ˆéšå±¤ç¶™æ‰¿ï¼‰
      this.animateContainer!(
        charContainer,
        charData.char,
        {
          ...params,
          id: charData.id,
          charIndex: charData.charIndex,
          totalChars: charData.totalChars,
          totalWords: charData.totalWords,
          phrasePhase: phrasePhase,
          phraseStartMs: phraseStartMs,
          phraseEndMs: phraseEndMs
        },
        nowMs,
        charData.start,
        charData.end,
        'char',
        phase
      );
    });
  }
  
  return true;
}
```

#### ğŸ†• æ–‡å­—ãƒ¬ãƒ™ãƒ«ã®å®Ÿè£…ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
```typescript
renderCharContainer(
  container: PIXI.Container,
  text: string,
  params: Record<string, any>,
  nowMs: number,
  startMs: number,
  endMs: number,
  phase: AnimationPhase,
  hierarchyType: HierarchyType
): boolean {
  
  // ğŸ†• æ–‡å­—ãƒ¬ãƒ™ãƒ«ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  const charOffsetX = params.charOffsetX || 0;
  const charOffsetY = params.charOffsetY || 0;
  const fontSize = params.fontSize || 32;
  const fontFamily = params.fontFamily || 'Arial';
  
  // ğŸ†• çŠ¶æ…‹åˆ¥è‰²è¨­å®šï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  const defaultTextColor = params.defaultTextColor || '#808080';
  const activeTextColor = params.activeTextColor || '#FF0000';
  const completedTextColor = params.completedTextColor || '#800000';
  
  // ğŸ†• ãƒ•ãƒ¬ãƒ¼ã‚ºç¶™æ‰¿æƒ…å ±ã®æ´»ç”¨ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  const phrasePhase = params.phrasePhase || phase;
  const headTime = params.headTime || 500;
  const tailTime = params.tailTime || 500;
  const phraseStartMs = params.phraseStartMs || startMs;
  const phraseEndMs = params.phraseEndMs || endMs;
  
  // ãƒ•ãƒ¬ãƒ¼ã‚ºãŒè¡¨ç¤ºæœŸé–“å¤–ã®å ´åˆã¯éè¡¨ç¤º
  const phraseInStartTime = phraseStartMs - headTime;
  const phraseOutEndTime = phraseEndMs + tailTime;
  
  if (nowMs < phraseInStartTime || nowMs > phraseOutEndTime) {
    container.visible = false;
    return true;
  }
  
  container.visible = true;
  
  // ğŸ†• æ–‡å­—ã®çŠ¶æ…‹ã«å¿œã˜ãŸè‰²æ±ºå®šï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  let textColor = defaultTextColor;
  let showSpecialEffect = false;
  
  if (nowMs < startMs) {
    // æ–‡å­—ã®ã‚¤ãƒ³å‰
    textColor = defaultTextColor;
    showSpecialEffect = false;
  } else if (nowMs <= endMs) {
    // æ–‡å­—ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æœŸé–“
    textColor = activeTextColor;
    showSpecialEffect = true;
  } else {
    // æ–‡å­—ã®ã‚¢ã‚¦ãƒˆå¾Œ
    textColor = completedTextColor;
    showSpecialEffect = false;
  }
  
  // ğŸ†• æ–‡å­—ãƒ†ã‚­ã‚¹ãƒˆã®æç”»ï¼ˆæ”¹å–„ç‰ˆï¼‰
  const textStyle = new PIXI.TextStyle({
    fontFamily: fontFamily,
    fontSize: fontSize,
    fill: textColor,  // çŠ¶æ…‹ã«å¿œã˜ãŸè‰²
    align: 'center',
    fontWeight: 'normal'
  });
  
  const textObj = new PIXI.Text(text, textStyle);
  textObj.anchor.set(0.5, 0.5);
  textObj.position.set(charOffsetX, charOffsetY);
  
  container.addChild(textObj);
  
  // ğŸ†• ç‰¹æ®ŠåŠ¹æœã®æç”»ï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–æœŸé–“ã®ã¿ã€å®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  if (showSpecialEffect) {
    const circleColor = parseInt((params.circleColor || '#FFFFFF').replace('#', '0x'));
    const circleSize = params.circleSize || fontSize + 8;
    const circleLineWidth = params.circleLineWidth || 8;
    const circleOpacity = params.circleOpacity || 1.0;
    
    const circle = new PIXI.Graphics();
    circle.lineStyle(circleLineWidth, circleColor, circleOpacity);
    circle.drawCircle(charOffsetX, charOffsetY, circleSize / 2);
    
    container.addChild(circle);
  }
  
  return true;
}
```

---

## ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã®å®Ÿè£…å‚è€ƒä¾‹

### åŸºæœ¬çš„ãªã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã®å®šç¾©

MultiLineTextãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹æ–¹æ³•ã‚’å‚è€ƒã«ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™ï¼š

```typescript
/**
 * ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼‰
 */

/**
 * ä¸‰æ¬¡ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆã‚¢ã‚¦ãƒˆï¼‰ï¼šæ—©ã„â†’é…ã„
 */
function easeOutCubic(t: number): number {
  return 1 - Math.pow(1 - t, 3);
}

/**
 * ä¸‰æ¬¡ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆã‚¤ãƒ³ï¼‰ï¼šé…ã„â†’æ—©ã„
 */
function easeInCubic(t: number): number {
  return t * t * t;
}

/**
 * å››æ¬¡ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆã‚¢ã‚¦ãƒˆï¼‰ï¼šã‚ˆã‚Šæ»‘ã‚‰ã‹ãªæ¸›é€Ÿ
 */
function easeOutQuart(t: number): number {
  return 1 - Math.pow(1 - t, 4);
}

/**
 * ã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼šè‡ªç„¶ãªåŠ æ¸›é€Ÿ
 */
function easeInOutSine(t: number): number {
  return -(Math.cos(Math.PI * t) - 1) / 2;
}
```

### é€Ÿåº¦ãƒ™ãƒ¼ã‚¹ã®è·é›¢è¨ˆç®—

MultiLineTextã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹é«˜åº¦ãªé€Ÿåº¦åˆ¶å¾¡ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼š

```typescript
/**
 * é€Ÿåº¦ãƒ™ãƒ¼ã‚¹ã®è·é›¢è¨ˆç®—
 * é€Ÿåº¦ã®æ™‚é–“ç©åˆ†ã«ã‚ˆã‚Šç§»å‹•è·é›¢ã‚’ç®—å‡º
 * @param elapsedTime çµŒéæ™‚é–“ï¼ˆmsï¼‰
 * @param duration ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç·æ™‚é–“ï¼ˆmsï¼‰
 * @param initialSpeed é–‹å§‹é€Ÿåº¦ï¼ˆpx/msï¼‰
 * @param finalSpeed çµ‚äº†é€Ÿåº¦ï¼ˆpx/msï¼‰
 * @param easingFn ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: easeOutCubicï¼‰
 * @returns ç§»å‹•è·é›¢ï¼ˆpxï¼‰
 */
function calculateDistanceFromSpeed(
  elapsedTime: number,
  duration: number,
  initialSpeed: number,
  finalSpeed: number,
  easingFn: (t: number) => number = easeOutCubic
): number {
  if (elapsedTime <= 0) return 0;
  if (elapsedTime >= duration) {
    // å®Œå…¨ãªç©åˆ†å€¤ã‚’è¨ˆç®—ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã«ã‚ˆã‚Šç•°ãªã‚‹ï¼‰
    // easeOutCubicã®å ´åˆï¼š3/4ã€easeInCubicã®å ´åˆï¼š1/4
    const integralValue = easingFn === easeOutCubic ? 0.75 : 0.25;
    return duration * (initialSpeed + (finalSpeed - initialSpeed) * integralValue);
  }
  
  // æ•°å€¤ç©åˆ†ï¼ˆå°å½¢å…¬å¼ï¼‰ã§æ­£ç¢ºãªè·é›¢ã‚’è¨ˆç®—
  const steps = Math.min(100, Math.ceil(elapsedTime)); // æœ€å¤§100ã‚¹ãƒ†ãƒƒãƒ—
  const dt = elapsedTime / steps;
  let distance = 0;
  
  for (let i = 0; i < steps; i++) {
    const t1 = i * dt;
    const t2 = (i + 1) * dt;
    const progress1 = t1 / duration;
    const progress2 = t2 / duration;
    const eased1 = easingFn(progress1);
    const eased2 = easingFn(progress2);
    const v1 = initialSpeed + (finalSpeed - initialSpeed) * eased1;
    const v2 = initialSpeed + (finalSpeed - initialSpeed) * eased2;
    distance += (v1 + v2) * dt / 2; // å°å½¢å…¬å¼
  }
  
  return distance;
}
```

### å…¥å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ã®ä½¿ç”¨ä¾‹

```typescript
// MultiLineTextã®å…¥å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…ä¾‹
if (nowMs < startMs) {
  // å…¥å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æœŸé–“ï¼šé€Ÿåº¦ãƒ™ãƒ¼ã‚¹ã®ç§»å‹•
  const elapsedTime = nowMs - inStartTime;
  const distance = calculateDistanceFromSpeed(
    elapsedTime,
    headTime,
    entranceInitialSpeed,  // é«˜é€Ÿã§é–‹å§‹ï¼ˆä¾‹: 2.0 px/msï¼‰
    activeSpeed,           // ä½é€Ÿã§çµ‚äº†ï¼ˆä¾‹: 0.05 px/msï¼‰
    easeOutCubic          // æ¸›é€Ÿã‚«ãƒ¼ãƒ–
  );
  posX = startPositionX - distance;
  alpha = elapsedTime / headTime;
}
```

### é€€å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ã®ä½¿ç”¨ä¾‹

```typescript
// é€€å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼šactiveSpeedã‹ã‚‰é«˜é€Ÿã¸åŠ é€Ÿ
const elapsedExitTime = nowMs - endMs;
const exitFinalSpeed = 2.0; // é€€å ´çµ‚äº†é€Ÿåº¦ï¼ˆé«˜é€Ÿï¼‰
const exitDistance = calculateDistanceFromSpeed(
  elapsedExitTime,
  tailTime,
  activeSpeed,      // ä½é€Ÿã§é–‹å§‹
  exitFinalSpeed,   // é«˜é€Ÿã§çµ‚äº†
  easeInCubic      // åŠ é€Ÿã‚«ãƒ¼ãƒ–
);
posX = basePos - exitDistance;
alpha = 1.0 - (elapsedExitTime / tailTime);
```

### ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å®šç¾©ã®æ¨å¥¨ä¾‹

```typescript
// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é€Ÿåº¦ã¨ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å®šç¾©
{ name: "headTime", type: "number", default: 500, min: 0, max: 2000, step: 50 },         // å…¥å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ï¼ˆmsï¼‰
{ name: "tailTime", type: "number", default: 500, min: 0, max: 2000, step: 50 },         // é€€å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ï¼ˆmsï¼‰
{ name: "entranceInitialSpeed", type: "number", default: 2.0, min: 0.1, max: 5.0, step: 0.1 }, // å…¥å ´é–‹å§‹é€Ÿåº¦ï¼ˆpx/msï¼‰
{ name: "activeSpeed", type: "number", default: 0.05, min: 0.01, max: 1.0, step: 0.01 }, // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã®ç§»å‹•é€Ÿåº¦ï¼ˆpx/msï¼‰
```

### ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã®é¸æŠã‚¬ã‚¤ãƒ‰

1. **easeOutCubic**: å…¥å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‘ãã€‚ç´ æ—©ãå§‹ã¾ã‚Šã€ãªã‚ã‚‰ã‹ã«æ¸›é€Ÿ
2. **easeInCubic**: é€€å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‘ãã€‚ã‚†ã£ãã‚Šå§‹ã¾ã‚Šã€åŠ é€Ÿã—ã¦æ¶ˆãˆã‚‹
3. **easeInOutSine**: åŒæ–¹å‘ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‘ãã€‚è‡ªç„¶ãªåŠ æ¸›é€Ÿ
4. **ç·šå½¢ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ãªã—ï¼‰**: ä¸€å®šé€Ÿåº¦ã®å‹•ãã€‚æ©Ÿæ¢°çš„ãªå°è±¡

### å®Ÿè£…æ™‚ã®æ³¨æ„ç‚¹

1. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: æ•°å€¤ç©åˆ†ã¯è¨ˆç®—ã‚³ã‚¹ãƒˆãŒé«˜ã„ãŸã‚ã€ã‚¹ãƒ†ãƒƒãƒ—æ•°ã‚’é©åˆ‡ã«åˆ¶é™
2. **ç²¾åº¦**: çŸ­ã„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ< 100msï¼‰ã§ã¯ç©åˆ†ã‚¹ãƒ†ãƒƒãƒ—æ•°ã‚’èª¿æ•´
3. **äº’æ›æ€§**: æ—¢å­˜ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã¨ã®æ•´åˆæ€§ã‚’ä¿ã¤

---

## ãƒ‡ãƒãƒƒã‚°ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### ğŸ†• å®Ÿè£…æ¸ˆã¿ãƒ‡ãƒãƒƒã‚°ã‚·ã‚¹ãƒ†ãƒ ã®æ´»ç”¨

#### 1. DebugManager ã¨ã®é€£æºï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
```typescript
// Engine.ts ã§ã®ä½¿ç”¨ä¾‹ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
engine.setDebugEnabled(true);    // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹
engine.setGridVisible(true);     // æ–¹çœ¼ç›®ç››ã‚Šè¡¨ç¤º

// ãƒ‡ãƒãƒƒã‚°ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®å–å¾—
const debugManager = engine.getDebugManager();
debugManager.dumpContainerHierarchy(container);  // éšå±¤æ§‹é€ å‡ºåŠ›
```

#### 2. ğŸ†• æ”¹å–„ã•ã‚ŒãŸãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³
```typescript
// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå†…ã§ã®ãƒ­ã‚°åˆ¶é™ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
animateContainer(container, text, params, nowMs, startMs, endMs, hierarchyType, phase) {
  // ğŸ†• 1ç§’ã«1å›ã®ãƒ­ã‚°åˆ¶é™ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  if (params.debugMode && nowMs % 1000 < 16) {
    console.log(`[${hierarchyType}] ${phase} - Time: ${nowMs}ms`);
  }
  
  // ğŸ†• è¡¨ç¤ºç¯„å›²å¤–ã®æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  const headTime = params.headTime || 500;
  const tailTime = params.tailTime || 500;
  const phraseStartMs = params.phraseStartMs || startMs;
  const phraseEndMs = params.phraseEndMs || endMs;
  
  if (nowMs < phraseStartMs - headTime || nowMs > phraseEndMs + tailTime) {
    container.visible = false;
    return true;  // æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
  }
  
  // ğŸ†• å¿…è¦ãªå ´åˆã®ã¿åº§æ¨™å¤‰æ›ã‚’æ›´æ–°ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  const targetX = this.calculatePositionX(nowMs, startMs, endMs, params);
  if (Math.abs(container.position.x - targetX) > 0.1) {  // èª¤å·®ã‚’è€ƒæ…®
    container.position.x = targetX;
    container.updateTransform();
  }
}
```

#### 3. ğŸ†• ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ã®å‘ä¸Šï¼ˆæ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
```typescript
// ğŸ†• ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ¨å¥¨å®Ÿè£…ï¼‰
private graphicsPool: PIXI.Graphics[] = [];

getPooledGraphics(): PIXI.Graphics {
  let graphics = this.graphicsPool.pop();
  if (!graphics) {
    graphics = new PIXI.Graphics();
  }
  graphics.clear();  // ãƒªã‚»ãƒƒãƒˆ
  return graphics;
}

returnToPool(graphics: PIXI.Graphics): void {
  if (this.graphicsPool.length < 10) {  // ãƒ—ãƒ¼ãƒ«ã‚µã‚¤ã‚ºåˆ¶é™
    this.graphicsPool.push(graphics);
  } else {
    graphics.destroy();  // éå‰°ãªå ´åˆã¯ç ´æ£„
  }
}
```

---

## ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ¬ã‚¸ã‚¹ãƒˆãƒªã¸ã®ç™»éŒ²

### æ–°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ç™»éŒ²æ‰‹é †ï¼ˆå®Ÿè£…æ¸ˆã¿ã‚·ã‚¹ãƒ†ãƒ ï¼‰

#### 1. templates/index.ts ã¸ã®è¿½åŠ 
```typescript
// templates/index.tsï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
export { FadeSlideText } from './FadeSlideText';
export { MultiLineText } from './MultiLineText';
export { GlitchText } from './GlitchText';
export { YourTemplate } from './YourTemplate';  // âœ¨ æ–°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆè¿½åŠ 
```

#### 2. templateRegistry.ts ã¸ã®ç™»éŒ²ï¼ˆå®Ÿè£…æ¸ˆã¿ã‚·ã‚¹ãƒ†ãƒ ï¼‰
```typescript
// templates/registry/templateRegistry.tsï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
import * as templates from '../index';

export const templateRegistry: TemplateRegistryEntry[] = [
  {
    id: 'fadeslidetext',
    name: 'ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ†ã‚­ã‚¹ãƒˆ',
    template: templates.FadeSlideText
  },
  {
    id: 'multilinetext',
    name: 'å¤šæ®µæ­Œè©ãƒ†ã‚­ã‚¹ãƒˆ',
    template: templates.MultiLineText
  },
  {
    id: 'glitchtext',
    name: 'ã‚°ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆ',
    template: templates.GlitchText
  },
  {
    id: 'yourtemplate',      // âœ¨ æ–°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
    name: 'ã‚ãªãŸã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ',
    template: templates.YourTemplate
  }
];
```

#### 3. ğŸ†• ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å‹•çš„èª­ã¿è¾¼ã¿ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
```typescript
// Engine ã§ã®è‡ªå‹•èª­ã¿è¾¼ã¿ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
import { templateRegistry } from '../templates/registry/templateRegistry';

// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®è‡ªå‹•ç™»éŒ²
templateRegistry.forEach(({ id, name, template }) => {
  const defaultParams = {};
  if (template.metadata && template.metadata.params) {
    template.metadata.params.forEach((param) => {
      defaultParams[param.name] = param.default;
    });
  }
  
  engine.addTemplate(id, template, { name }, defaultParams);
});
```

---

## UIçµ±åˆã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### ğŸ†• å®Ÿè£…æ¸ˆã¿UIæ©Ÿèƒ½ã®æ´»ç”¨

#### 1. è¤‡æ•°é¸æŠå¯¾å¿œï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
```typescript
// TemplateSelector.tsx ã§ã®ä½¿ç”¨ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
interface TemplateSelectorProps {
  templates: Array<{id: string, name: string, description?: string}>;
  selectedTemplateId: string;
  selectedPhraseIds?: string[];  // âœ¨ è¤‡æ•°é¸æŠå¯¾å¿œï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  onSelect: (templateId: string) => void;
}

// ğŸ†• ä¸€æ‹¬é©ç”¨ã®å®Ÿè£…ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
const handleBatchApply = (templateId: string) => {
  if (selectedPhraseIds && selectedPhraseIds.length > 1) {
    // Engine ã®ä¸€æ‹¬é©ç”¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
    const success = engine.batchAssignTemplate(selectedPhraseIds, templateId, true);
    
    if (success) {
      // ğŸ†• æˆåŠŸé€šçŸ¥ã®ç™ºç«ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
      const event = new CustomEvent('template-batch-applied', {
        detail: {
          templateName: templateName,
          objectIds: selectedPhraseIds,
          objectType: 'ãƒ•ãƒ¬ãƒ¼ã‚º'
        }
      });
      window.dispatchEvent(event);
    }
  }
};
```

#### 2. ğŸ†• ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¤‰æ›´æ™‚ã®UXæ”¹å–„ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
```typescript
// ğŸ†• ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¿æŒã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æä¾›ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
const handleTemplateChange = (templateId: string, preserveParams: boolean = true) => {
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠã«åŸºã¥ããƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¿æŒï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  const success = engine.assignTemplate(objectId, templateId, preserveParams);
  
  if (success) {
    // ğŸ†• å¤‰æ›´çµæœã®é€šçŸ¥ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
    showNotification(`ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’${preserveParams ? 'ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¿æŒã§' : ''}å¤‰æ›´ã—ã¾ã—ãŸ`);
  }
};
```

#### 3. ğŸ†• Undo/Redoçµ±åˆï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
```typescript
// ğŸ†• Undo/Redoæ©Ÿèƒ½ã®UIçµ±åˆï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
const UndoRedoPanel: React.FC = () => {
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  
  const handleUndo = () => {
    const success = engine.undo();
    if (success) {
      updateUndoRedoState();
      showNotification('æ“ä½œã‚’å…ƒã«æˆ»ã—ã¾ã—ãŸ');
    }
  };
  
  const handleRedo = () => {
    const success = engine.redo();
    if (success) {
      updateUndoRedoState();
      showNotification('æ“ä½œã‚’ã‚„ã‚Šç›´ã—ã¾ã—ãŸ');
    }
  };
  
  const updateUndoRedoState = () => {
    setCanUndo(engine.canUndo());
    setCanRedo(engine.canRedo());
  };
  
  // ğŸ†• å±¥æ­´æƒ…å ±ã®å–å¾—ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
  const historyInfo = engine.getUndoRedoHistory();
  
  return (
    <div className="undo-redo-panel">
      <button onClick={handleUndo} disabled={!canUndo}>
        Undo ({historyInfo.currentIndex}/{historyInfo.history.length})
      </button>
      <button onClick={handleRedo} disabled={!canRedo}>
        Redo
      </button>
    </div>
  );
};
```

#### 4. ğŸ†• ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®ã®UIå®Ÿè£…ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
```typescript
// ğŸ†• ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®å®Ÿè£…ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
const handleParameterChange = debounce((params: Record<string, any>) => {
  // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
  engine.updateGlobalParams(params, false);  // saveState: false for real-time
}, 100);  // 100ms ã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´å®Œäº†æ™‚ã®çŠ¶æ…‹ä¿å­˜
const handleParameterChangeComplete = (params: Record<string, any>) => {
  engine.updateGlobalParams(params, true);  // saveState: true for history
};
```

---

## å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ã¾ã¨ã‚

### 1. ğŸ†• éšå±¤ç¶™æ‰¿å¯¾å¿œãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å®Œå…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ™ãƒ¼ã‚¹ï¼‰

```typescript
export const YourTemplate: IAnimationTemplate = {
  metadata: {
    params: [
      // ğŸ†• éšå±¤å…±é€šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
      { name: "fontSize", type: "number", default: 32, min: 12, max: 128, step: 1 },
      { name: "fontFamily", type: "string", default: "Arial" },
      
      // ğŸ†• çŠ¶æ…‹åˆ¥è‰²è¨­å®šï¼ˆFadeSlideTextãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
      { name: "defaultTextColor", type: "color", default: "#808080" },
      { name: "activeTextColor", type: "color", default: "#FF0000" },
      { name: "completedTextColor", type: "color", default: "#800000" },
      
      // ğŸ†• ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
      { name: "headTime", type: "number", default: 500, min: 0, max: 2000, step: 50 },
      { name: "tailTime", type: "number", default: 500, min: 0, max: 2000, step: 50 },
      { name: "initialSpeed", type: "number", default: 0.1, min: 0.01, max: 1.0, step: 0.01 },
      { name: "activeSpeed", type: "number", default: 0.01, min: 0.001, max: 0.1, step: 0.001 },
      
      // ğŸ†• éšå±¤åˆ¥ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
      { name: "phraseOffsetX", type: "number", default: 0, min: -200, max: 200, step: 1 },
      { name: "wordOffsetX", type: "number", default: 0, min: -100, max: 100, step: 1 },
      { name: "charOffsetX", type: "number", default: 0, min: -50, max: 50, step: 1 },
      
      // ğŸ†• è¦–è¦šåŠ¹æœåˆ¶å¾¡ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
      { name: "circleSize", type: "number", default: 40, min: 10, max: 200, step: 1 },
      { name: "circleLineWidth", type: "number", default: 8, min: 1, max: 20, step: 1 },
      { name: "circleOpacity", type: "number", default: 1.0, min: 0.0, max: 1.0, step: 0.01 },
      
      // ãƒ‡ãƒãƒƒã‚°ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
      { name: "debugMode", type: "boolean", default: false }
    ]
  },
  
  // ğŸ†• éšå±¤æ§‹é€ ä¿æŒã®ãŸã‚ã®è¦ç´ å‰Šé™¤ï¼ˆå¿…é ˆå®Ÿè£…ï¼‰
  removeVisualElements(container: PIXI.Container): void {
    const childrenToKeep: PIXI.DisplayObject[] = [];
    const childrenToRemove: PIXI.DisplayObject[] = [];
    
    container.children.forEach(child => {
      if (child instanceof PIXI.Container && 
          (child as any).name && 
          ((child as any).name.includes('_container_'))) {
        childrenToKeep.push(child);
      } else {
        childrenToRemove.push(child);
      }
    });
    
    childrenToRemove.forEach(child => {
      container.removeChild(child);
      child.destroy();
    });
  },
  
  // ğŸ†• ãƒ¡ã‚¤ãƒ³ã®éšå±¤å¯¾å¿œå®Ÿè£…ï¼ˆå¿…é ˆå®Ÿè£…ï¼‰
  animateContainer(
    container: PIXI.Container,
    text: string | string[],
    params: Record<string, any>,
    nowMs: number,
    startMs: number,
    endMs: number,
    hierarchyType: HierarchyType,
    phase: AnimationPhase
  ): boolean {
    
    // å…±é€šåˆæœŸåŒ–
    const textContent = Array.isArray(text) ? text.join('') : text;
    container.visible = true;
    this.removeVisualElements!(container);
    
    // éšå±¤åˆ¥å‡¦ç†
    switch (hierarchyType) {
      case 'phrase':
        return this.renderPhraseContainer!(container, textContent, params, nowMs, startMs, endMs, phase, hierarchyType);
      case 'word':
        return this.renderWordContainer!(container, textContent, params, nowMs, startMs, endMs, phase, hierarchyType);
      case 'char':  
        return this.renderCharContainer!(container, textContent, params, nowMs, startMs, endMs, phase, hierarchyType);
      default:
        return false;
    }
  },
  
  // ğŸ†• ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ¬ãƒ™ãƒ«å®Ÿè£…ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ï¼‰
  renderPhraseContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType): boolean {
    // ãƒ•ãƒ¬ãƒ¼ã‚ºå…¨ä½“åˆ¶å¾¡ã®å®Ÿè£…
    // - å…¨ä½“ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    // - ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³/ã‚¢ã‚¦ãƒˆ
    // - å­è¦ç´ ã¸ã®å½±éŸ¿
    // (FadeSlideTextã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å‚è€ƒã«å®Ÿè£…)
    return true;
  },
  
  // ğŸ†• å˜èªãƒ¬ãƒ™ãƒ«å®Ÿè£…ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ï¼‰
  renderWordContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType): boolean {
    // å˜èªå˜ä½åˆ¶å¾¡ã®å®Ÿè£…
    // - æ–‡å­—æ•°ã«å¿œã˜ãŸè¦–è¦šè¦ç´ 
    // - å˜èªãƒ¬ãƒ™ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    // - ãƒ•ãƒ¬ãƒ¼ã‚ºçŠ¶æ…‹ã®ç¶™æ‰¿
    // (FadeSlideTextã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å‚è€ƒã«å®Ÿè£…)
    return true;
  },
  
  // ğŸ†• æ–‡å­—ãƒ¬ãƒ™ãƒ«å®Ÿè£…ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ï¼‰
  renderCharContainer(container, text, params, nowMs, startMs, endMs, phase, hierarchyType): boolean {
    // æ–‡å­—å€‹åˆ¥åˆ¶å¾¡ã®å®Ÿè£…
    // - æ–‡å­—ã®çŠ¶æ…‹ã«å¿œã˜ãŸè¡¨ç¤º
    // - è‰²ãƒ»ã‚µã‚¤ã‚ºå¤‰æ›´
    // - ä½ç½®èª¿æ•´
    // (FadeSlideTextã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å‚è€ƒã«å®Ÿè£…)
    return true;
  },
  
  // ğŸ†• ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆå®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  easeOutCubic(t: number): number {
    return 1 - Math.pow(1 - t, 3);
  },
  
  easeInCubic(t: number): number {
    return t * t * t;
  },
  
  // ğŸ†• é€Ÿåº¦ãƒ™ãƒ¼ã‚¹ã®è·é›¢è¨ˆç®—ï¼ˆMultiLineTextãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  calculateDistanceFromSpeed(
    elapsedTime: number,
    duration: number,
    initialSpeed: number,
    finalSpeed: number,
    easingFn: (t: number) => number = this.easeOutCubic
  ): number {
    if (elapsedTime <= 0) return 0;
    if (elapsedTime >= duration) {
      const integralValue = easingFn === this.easeOutCubic ? 0.75 : 0.25;
      return duration * (initialSpeed + (finalSpeed - initialSpeed) * integralValue);
    }
    
    const steps = Math.min(100, Math.ceil(elapsedTime));
    const dt = elapsedTime / steps;
    let distance = 0;
    
    for (let i = 0; i < steps; i++) {
      const t1 = i * dt;
      const t2 = (i + 1) * dt;
      const progress1 = t1 / duration;
      const progress2 = t2 / duration;
      const eased1 = easingFn(progress1);
      const eased2 = easingFn(progress2);
      const v1 = initialSpeed + (finalSpeed - initialSpeed) * eased1;
      const v2 = initialSpeed + (finalSpeed - initialSpeed) * eased2;
      distance += (v1 + v2) * dt / 2;
    }
    
    return distance;
  }
};
```

### 2. ğŸ†• ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰

```typescript
// ğŸ†• ãƒ­ã‚°åˆ¶é™ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
if (params.debugMode && nowMs % 1000 < 16) {
  console.log(`ãƒ‡ãƒãƒƒã‚°æƒ…å ±: ${hierarchyType}`);
}

// ğŸ†• æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
const headTime = params.headTime || 500;
const tailTime = params.tailTime || 500;
const phraseStartMs = params.phraseStartMs || startMs;
const phraseEndMs = params.phraseEndMs || endMs;

if (nowMs < phraseStartMs - headTime || nowMs > phraseEndMs + tailTime) {
  container.visible = false;
  return true;
}

// ğŸ†• å¤‰æ›´æ™‚ã®ã¿æ›´æ–°ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
const targetX = this.calculatePosition(nowMs, startMs, endMs, params);
if (Math.abs(container.position.x - targetX) > 0.1) {
  container.position.x = targetX;
  container.updateTransform();
}
```

### 3. ğŸ†• UIçµ±åˆãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰

```typescript
// ğŸ†• è¤‡æ•°é¸æŠå¯¾å¿œã®ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
const handleBatchApply = (templateId: string) => {
  if (selectedPhraseIds?.length > 1) {
    // ä¸€æ‹¬é©ç”¨ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
    const success = engine.batchAssignTemplate(selectedPhraseIds, templateId, preserveParams);
    
    if (success) {
      // çµæœé€šçŸ¥ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
      showNotification(`${selectedPhraseIds.length}å€‹ã®ãƒ•ãƒ¬ãƒ¼ã‚ºã«é©ç”¨ã—ã¾ã—ãŸ`);
    }
  } else {
    // å˜ä¸€é©ç”¨
    engine.assignTemplate(objectId, templateId, preserveParams);
  }
};

// ğŸ†• ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´ã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
const handleParameterChange = debounce((params) => {
  engine.updateGlobalParams(params, false);  // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
}, 100);

// ğŸ†• Undo/Redoçµ±åˆï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
const handleUndoableAction = (action: () => void) => {
  action();  // saveState: true ã§çŠ¶æ…‹ä¿å­˜ã•ã‚Œã‚‹
  updateUndoRedoUI();
};
```

---

## ã¾ã¨ã‚

### ğŸ†• å®Ÿè£…å®Œäº†ã‚·ã‚¹ãƒ†ãƒ ã§ã®é–‹ç™ºæŒ‡é‡ï¼ˆ2025å¹´5æœˆç‰ˆï¼‰

1. **éšå±¤ç¶™æ‰¿ã‚’æ„è­˜ã—ãŸè¨­è¨ˆ**: ãƒ•ãƒ¬ãƒ¼ã‚ºâ†’å˜èªâ†’æ–‡å­—ã®ç¶™æ‰¿é–¢ä¿‚ã‚’è€ƒæ…®
2. **å®Ÿè£…æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ´»ç”¨**: FadeSlideTextã€MultiLineTextã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å‚è€ƒ
3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**: ãƒ­ã‚°åˆ¶é™ã€æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ã€é¸æŠçš„æ›´æ–°
4. **UIçµ±åˆ**: è¤‡æ•°é¸æŠã€ä¸€æ‹¬æ“ä½œã€Undo/Redoã€é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®æ´»ç”¨
5. **ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½**: DebugManagerã€GridOverlay ã®ç©æ¥µçš„æ´»ç”¨
6. **ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ¬ã‚¸ã‚¹ãƒˆãƒª**: ä¸­å¤®ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã§ã®çµ±ä¸€çš„ç™»éŒ²

### ğŸ†• é‡è¦ãªå®Ÿè£…ãƒã‚¤ãƒ³ãƒˆï¼ˆå®Ÿè£…å®Œäº†ç‰ˆï¼‰

#### 1. éšå±¤ç¶™æ‰¿ã‚·ã‚¹ãƒ†ãƒ ã®ç†è§£
- **è‡ªå‹•ç¶™æ‰¿**: è¦ªã§è¨­å®šã—ãŸãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒå­ã«è‡ªå‹•é©ç”¨
- **ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰**: å­ãƒ¬ãƒ™ãƒ«ã§ã®å€‹åˆ¥ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆè¨­å®š
- **ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç¶™æ‰¿**: éšå±¤çš„ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰

#### 2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®
- **è¡¨ç¤ºç¯„å›²åˆ¤å®š**: å¿…è¦æ™‚ã®ã¿æ›´æ–°å‡¦ç†ã‚’å®Ÿè¡Œ
- **ãƒ­ã‚°åˆ¶é™**: ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®é©åˆ‡ãªåˆ¶é™ï¼ˆ1ç§’ã«1å›ç¨‹åº¦ï¼‰
- **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«ã®æ´»ç”¨

#### 3. ä¿å®ˆæ€§ã®ç¢ºä¿
- **çµ±ä¸€ã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³**: removeVisualElementsã€animateContainer ã®æ¨™æº–å®Ÿè£…
- **éšå±¤åˆ¥å‡¦ç†**: æ˜ç¢ºãªå½¹å‰²åˆ†æ‹…ï¼ˆrenderPhraseContainerã€renderWordContainerã€renderCharContainerï¼‰
- **ãƒ‡ãƒãƒƒã‚°å¯¾å¿œ**: ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®å®¹æ˜“ã•

#### 4. ğŸ†• æ”¹å–„ã•ã‚ŒãŸæ©Ÿèƒ½ã®æ´»ç”¨
- **ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¿æŒã‚·ã‚¹ãƒ†ãƒ **: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¤‰æ›´æ™‚ã®å…±é€šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è‡ªå‹•ä¿æŒ
- **Undo/Redoæ©Ÿèƒ½**: å…¨æ“ä½œã®å±¥æ­´ç®¡ç†ï¼ˆ20ã‚¹ãƒ†ãƒƒãƒ—ï¼‰
- **ä¸€æ‹¬æ“ä½œ**: è¤‡æ•°ãƒ•ãƒ¬ãƒ¼ã‚ºã¸ã®åŒæ™‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé©ç”¨
- **ãƒ‡ãƒãƒƒã‚°çµ±åˆ**: GridOverlayã€DebugManager ã®æ´»ç”¨

### ğŸ†• æ¬¡ä¸–ä»£æ©Ÿèƒ½ã¸ã®æº–å‚™

å®Ÿè£…å®Œäº†ã‚·ã‚¹ãƒ†ãƒ ã¯ä»¥ä¸‹ã®æ‹¡å¼µã«å¯¾å¿œå¯èƒ½ï¼š

1. **ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆåˆæˆ**: è¤‡æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®åŠ¹æœé‡ã­åˆã‚ã›
2. **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼**: é©ç”¨å‰ã®åŠ¹æœç¢ºèª
3. **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›²ç·šç·¨é›†**: ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°
4. **ãƒ—ãƒªã‚»ãƒƒãƒˆç®¡ç†**: è¨­å®šã®ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿
5. **AIæ”¯æ´æ©Ÿèƒ½**: è‡ªå‹•ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ¨å¥¨

ã“ã®æ‰‹é †æ›¸ã«å¾“ã£ã¦æ–°ã—ã„ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€**Lyralive v0.6.0**ã®é«˜åº¦ãªæ©Ÿèƒ½ï¼ˆéšå±¤ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã€PixiJSãƒ•ã‚£ãƒ«ã‚¿ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£æ“ä½œã€æ–‡å­—ã‚«ã‚¦ãƒ³ãƒˆç®¡ç†ç­‰ï¼‰ã‚’æ´»ç”¨ã—ãŸé«˜å“è³ªãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç¢ºå®Ÿã«ä½œæˆã§ãã¾ã™ã€‚å®Ÿè£…æ¸ˆã¿ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å®Ÿéš›ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åŸºã«ã—ãŸå®Ÿè·µçš„ãªã‚¬ã‚¤ãƒ‰ã¨ã—ã¦ã€å®‰å®šã—ãŸé–‹ç™ºã‚’æ”¯æ´ã—ã¾ã™ã€‚

---

**æœ€çµ‚æ›´æ–°**: 2025å¹´6æœˆ - Electronãƒ™ãƒ¼ã‚¹ç¾è¡Œã‚·ã‚¹ãƒ†ãƒ å¯¾å¿œç‰ˆ  
**å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ **: éšå±¤ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã€PixiJSãƒ•ã‚£ãƒ«ã‚¿ã€RenderTextureã€FontServiceã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–å®Œå…¨çµ±åˆå¯¾å¿œ  
**å®Ÿè£…å‚è€ƒ**: FadeSlideText, MultiLineText, GlitchText, WordSlideText ã®å®Ÿéš›ã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹  
**é«˜åº¦æ©Ÿèƒ½**: ãƒ†ã‚¯ã‚¹ãƒãƒ£æ“ä½œã€æ–‡å­—ã‚«ã‚¦ãƒ³ãƒˆç®¡ç†ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã€ãƒ‡ãƒãƒƒã‚°ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨ç¶²ç¾…